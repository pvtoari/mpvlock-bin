From 3ecf0eda41fac272c5bc6666fec757e8a45cbe2f Mon Sep 17 00:00:00 2001
From: RAMA <70065309+nomadxxxx@users.noreply.github.com>
Date: Mon, 7 Apr 2025 15:57:25 +1000
Subject: [PATCH 1/4] mpvpaper

---
 src/renderer/Renderer.cpp           | 233 +++++++++++++++++-----------
 src/renderer/widgets/Background.cpp |  47 +++---
 2 files changed, 172 insertions(+), 108 deletions(-)

diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index d5533bfa..6be90f6e 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -17,6 +17,8 @@
 #include "widgets/Label.hpp"
 #include "widgets/Image.hpp"
 #include "widgets/Shape.hpp"
+#include <cstdlib>  // For system()
+#include <string>
 
 inline const float fullVerts[] = {
     1, 0, // top right
@@ -197,6 +199,37 @@ CRenderer::CRenderer() {
     asyncResourceGatherer = makeUnique<CAsyncResourceGatherer>();
 
     g_pAnimationManager->createAnimation(0.f, opacity, g_pConfigManager->m_AnimationTree.getConfig("fadeIn"));
+
+    mpvpaperRunning = false;  // Initialize the flag
+}
+
+CRenderer::~CRenderer() {
+    stopMpvpaper();  // Ensure mpvpaper is stopped when the renderer is destroyed
+}
+
+void CRenderer::startMpvpaper(const std::string& monitor, const std::string& videoPath) {
+    if (mpvpaperRunning) {
+        stopMpvpaper();  // Ensure no existing mpvpaper instance is running
+    }
+
+    // Construct the mpvpaper command
+    std::string mpvpaperCmd = "mpvpaper -o \"--loop=inf --no-osc --no-osd-bar\" " + monitor + " " + videoPath + " &";
+    system(mpvpaperCmd.c_str());
+    mpvpaperRunning = true;
+    currentMonitor = monitor;
+    currentVideoPath = videoPath;
+
+    Debug::log(LOG, "Started mpvpaper on monitor {} with video {}", monitor, videoPath);
+}
+
+void CRenderer::stopMpvpaper() {
+    if (mpvpaperRunning) {
+        system("pkill mpvpaper");
+        mpvpaperRunning = false;
+        currentMonitor = "";
+        currentVideoPath = "";
+        Debug::log(LOG, "Stopped mpvpaper");
+    }
 }
 
 //
@@ -210,7 +243,7 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
     glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &fb);
     pushFb(fb);
 
-    glClearColor(0.0, 0.0, 0.0, 0.0);
+    glClearColor(0.0, 0.0, 0.0, 0.0);  // Clear to transparent
     glClear(GL_COLOR_BUFFER_BIT);
 
     glEnable(GL_BLEND);
@@ -220,11 +253,31 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
     const bool      WAITFORASSETS = !g_pHyprlock->m_bImmediateRender && !asyncResourceGatherer->gathered;
 
     if (!WAITFORASSETS) {
-        // render widgets
+        // Render widgets
         const auto WIDGETS = getOrCreateWidgetsFor(surf);
+        bool hasVideoBackground = false;
+
+        // Check for a video background
         for (auto& w : WIDGETS) {
+            if (auto* bg = dynamic_cast<CBackground*>(w.get()); bg) {
+                if (bg->isVideoBackground) {
+                    hasVideoBackground = true;
+                    // Launch mpvpaper if not already running
+                    if (!mpvpaperRunning) {
+                        std::string monitor = surf.m_outputRef.lock()->stringPort;  // Get monitor output name
+                        startMpvpaper(monitor, bg->videoPath);
+                    }
+                    // Skip rendering the background widget since mpvpaper is handling it
+                    continue;
+                }
+            }
             feedback.needsFrame = w->draw({opacity->value()}) || feedback.needsFrame;
         }
+
+        // If we have a video background, ensure the background is transparent
+        if (hasVideoBackground) {
+            glClearColor(0.0, 0.0, 0.0, 0.0);  // Ensure transparency
+        }
     }
 
     feedback.needsFrame = feedback.needsFrame || !asyncResourceGatherer->gathered;
@@ -233,7 +286,6 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
 
     return feedback;
 }
-
 void CRenderer::renderRect(const CBox& box, const CHyprColor& col, int rounding) {
     const auto ROUNDEDBOX = box.copy().round();
     Mat3x3     matrix     = projMatrix.projectBox(ROUNDEDBOX, HYPRUTILS_TRANSFORM_NORMAL, box.rot);
@@ -386,7 +438,6 @@ void CRenderer::renderTextureMix(const CBox& box, const CTexture& tex, const CTe
 
     glBindTexture(tex.m_iTarget, 0);
 }
-
 template <class Widget>
 static void createWidget(std::vector<SP<IWidget>>& widgets) {
     const auto W = makeShared<Widget>();
@@ -535,90 +586,92 @@ void CRenderer::blurFB(const CFramebuffer& outfb, SBlurParams params) {
     for (int i = params.passes - 1; i >= 0; --i) {
         drawPass(&blurShader2); // up
     }
-
-    // finalize the image
-    {
-        if (currentRenderToFB == &mirrors[0])
-            mirrors[1].bind();
-        else
-            mirrors[0].bind();
-
-        glActiveTexture(GL_TEXTURE0);
-
-        glBindTexture(currentRenderToFB->m_cTex.m_iTarget, currentRenderToFB->m_cTex.m_iTexID);
-
-        glTexParameteri(currentRenderToFB->m_cTex.m_iTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-
-        glUseProgram(blurFinishShader.program);
-
-        glUniformMatrix3fv(blurFinishShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
-        glUniform1f(blurFinishShader.noise, params.noise);
-        glUniform1f(blurFinishShader.brightness, params.brightness);
-        glUniform1i(blurFinishShader.colorize, params.colorize.has_value());
-        if (params.colorize.has_value())
-            glUniform3f(blurFinishShader.colorizeTint, params.colorize->r, params.colorize->g, params.colorize->b);
-        glUniform1f(blurFinishShader.boostA, params.boostA);
-
-        glUniform1i(blurFinishShader.tex, 0);
-
-        glVertexAttribPointer(blurFinishShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-        glVertexAttribPointer(blurFinishShader.texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-
-        glEnableVertexAttribArray(blurFinishShader.posAttrib);
-        glEnableVertexAttribArray(blurFinishShader.texAttrib);
-
-        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-
-        glDisableVertexAttribArray(blurFinishShader.posAttrib);
-        glDisableVertexAttribArray(blurFinishShader.texAttrib);
-
-        if (currentRenderToFB != &mirrors[0])
-            currentRenderToFB = &mirrors[0];
-        else
-            currentRenderToFB = &mirrors[1];
+        // finalize the image
+        {
+            if (currentRenderToFB == &mirrors[0])
+                mirrors[1].bind();
+            else
+                mirrors[0].bind();
+    
+            glActiveTexture(GL_TEXTURE0);
+    
+            glBindTexture(currentRenderToFB->m_cTex.m_iTarget, currentRenderToFB->m_cTex.m_iTexID);
+    
+            glTexParameteri(currentRenderToFB->m_cTex.m_iTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    
+            glUseProgram(blurFinishShader.program);
+    
+            glUniformMatrix3fv(blurFinishShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
+            glUniform1f(blurFinishShader.noise, params.noise);
+            glUniform1f(blurFinishShader.brightness, params.brightness);
+            glUniform1i(blurFinishShader.colorize, params.colorize.has_value());
+            if (params.colorize.has_value())
+                glUniform3f(blurFinishShader.colorizeTint, params.colorize->r, params.colorize->g, params.colorize->b);
+            glUniform1f(blurFinishShader.boostA, params.boostA);
+    
+            glUniform1i(blurFinishShader.tex, 0);
+    
+            glVertexAttribPointer(blurFinishShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+            glVertexAttribPointer(blurFinishShader.texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+    
+            glEnableVertexAttribArray(blurFinishShader.posAttrib);
+            glEnableVertexAttribArray(blurFinishShader.texAttrib);
+    
+            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+    
+            glDisableVertexAttribArray(blurFinishShader.posAttrib);
+            glDisableVertexAttribArray(blurFinishShader.texAttrib);
+    
+            if (currentRenderToFB != &mirrors[0])
+                currentRenderToFB = &mirrors[0];
+            else
+                currentRenderToFB = &mirrors[1];
+        }
+    
+        // finish
+        outfb.bind();
+        renderTexture(box, currentRenderToFB->m_cTex, 1.0, 0, HYPRUTILS_TRANSFORM_NORMAL);
+    
+        glEnable(GL_BLEND);
     }
-
-    // finish
-    outfb.bind();
-    renderTexture(box, currentRenderToFB->m_cTex, 1.0, 0, HYPRUTILS_TRANSFORM_NORMAL);
-
-    glEnable(GL_BLEND);
-}
-
-void CRenderer::pushFb(GLint fb) {
-    boundFBs.push_back(fb);
-    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fb);
-}
-
-void CRenderer::popFb() {
-    boundFBs.pop_back();
-    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, boundFBs.empty() ? 0 : boundFBs.back());
-}
-
-void CRenderer::removeWidgetsFor(OUTPUTID id) {
-    widgets.erase(id);
-}
-
-void CRenderer::reconfigureWidgetsFor(OUTPUTID id) {
-    // TODO: reconfigure widgets by just calling their configure method again.
-    // Requires a way to get a widgets config properties.
-    // I think the best way would be to store the anonymos key of the widget config.
-    removeWidgetsFor(id);
-}
-
-void CRenderer::startFadeIn() {
-    Debug::log(LOG, "Starting fade in");
-    *opacity = 1.f;
-
-    opacity->setCallbackOnEnd([this](auto) { opacity->setConfig(g_pConfigManager->m_AnimationTree.getConfig("fadeOut")); }, true);
-}
-
-void CRenderer::startFadeOut(bool unlock, bool immediate) {
-    if (immediate)
-        opacity->setValueAndWarp(0.f);
-    else
-        *opacity = 0.f;
-
-    if (unlock)
-        opacity->setCallbackOnEnd([](auto) { g_pHyprlock->releaseSessionLock(); }, true);
-}
+    
+    void CRenderer::pushFb(GLint fb) {
+        boundFBs.push_back(fb);
+        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fb);
+    }
+    
+    void CRenderer::popFb() {
+        boundFBs.pop_back();
+        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, boundFBs.empty() ? 0 : boundFBs.back());
+    }
+    
+    void CRenderer::removeWidgetsFor(OUTPUTID id) {
+        widgets.erase(id);
+    }
+    
+    void CRenderer::reconfigureWidgetsFor(OUTPUTID id) {
+        // TODO: reconfigure widgets by just calling their configure method again.
+        // Requires a way to get a widgets config properties.
+        // I think the best way would be to store the anonymos key of the widget config.
+        removeWidgetsFor(id);
+    }
+    
+    void CRenderer::startFadeIn() {
+        Debug::log(LOG, "Starting fade in");
+        *opacity = 1.f;
+    
+        opacity->setCallbackOnEnd([this](auto) { opacity->setConfig(g_pConfigManager->m_AnimationTree.getConfig("fadeOut")); }, true);
+    }
+    
+    void CRenderer::startFadeOut(bool unlock, bool immediate) {
+        if (immediate)
+            opacity->setValueAndWarp(0.f);
+        else
+            *opacity = 0.f;
+    
+        if (unlock)
+            opacity->setCallbackOnEnd([this](auto) {
+                stopMpvpaper();  // Stop mpvpaper when fading out
+                g_pHyprlock->releaseSessionLock();
+            }, true);
+    }
\ No newline at end of file
diff --git a/src/renderer/widgets/Background.cpp b/src/renderer/widgets/Background.cpp
index 67fb0162..c75026c0 100644
--- a/src/renderer/widgets/Background.cpp
+++ b/src/renderer/widgets/Background.cpp
@@ -35,19 +35,30 @@ void CBackground::configure(const std::unordered_map<std::string, std::any>& pro
         crossFadeTime     = std::any_cast<Hyprlang::FLOAT>(props.at("crossfade_time"));
 
     } catch (const std::bad_any_cast& e) {
-        RASSERT(false, "Failed to construct CBackground: {}", e.what()); //
+        RASSERT(false, "Failed to construct CBackground: {}", e.what());
     } catch (const std::out_of_range& e) {
-        RASSERT(false, "Missing propperty for CBackground: {}", e.what()); //
+        RASSERT(false, "Missing propperty for CBackground: {}", e.what());
     }
 
     isScreenshot = path == "screenshot";
 
+    // Check if the path is an MP4 file
+    if (path.ends_with(".mp4")) {
+        isVideoBackground = true;
+        videoPath = path;
+        Debug::log(LOG, "Detected video background: {}", path);
+        resourceID = "";  // Skip loading a static texture since we'll use mpvpaper
+    } else {
+        isVideoBackground = false;
+        videoPath = "";
+        resourceID = isScreenshot ? CScreencopyFrame::getResourceId(pOutput) : (!path.empty() ? "background:" + path : "");
+    }
+
     viewport   = pOutput->getViewport();
     outputPort = pOutput->stringPort;
     transform  = isScreenshot ? wlTransformToHyprutils(invertTransform(pOutput->transform)) : HYPRUTILS_TRANSFORM_NORMAL;
 
-    if (isScreenshot) {
-        resourceID = CScreencopyFrame::getResourceId(pOutput);
+    if (isScreenshot && !isVideoBackground) {
         // When the initial gather of the asyncResourceGatherer is completed (ready), all DMAFrames are available.
         // Dynamic ones are tricky, because a screencopy would copy hyprlock itself.
         if (g_pRenderer->asyncResourceGatherer->gathered) {
@@ -59,16 +70,14 @@ void CBackground::configure(const std::unordered_map<std::string, std::any>& pro
             Debug::log(ERR, "No screencopy support! path=screenshot won't work. Falling back to background color.");
             resourceID = "";
         }
+    }
 
-    } else if (!path.empty())
-        resourceID = "background:" + path;
-
-    if (!isScreenshot && reloadTime > -1) {
+    if (!isScreenshot && !isVideoBackground && reloadTime > -1) {
         try {
             modificationTime = std::filesystem::last_write_time(absolutePath(path, ""));
         } catch (std::exception& e) { Debug::log(ERR, "{}", e.what()); }
 
-        plantReloadTimer(); // No reloads for screenshots.
+        plantReloadTimer(); // No reloads for screenshots or videos
     }
 }
 
@@ -110,6 +119,11 @@ static void onAssetCallback(WP<CBackground> ref) {
 }
 
 bool CBackground::draw(const SRenderData& data) {
+    if (isVideoBackground) {
+        // Skip rendering the static background since mpvpaper is handling the video
+        Debug::log(LOG, "Skipping static background rendering; using video background via mpvpaper");
+        return false;
+    }
 
     if (resourceID.empty()) {
         CHyprColor col = color;
@@ -135,7 +149,6 @@ bool CBackground::draw(const SRenderData& data) {
     }
 
     if (fade || ((blurPasses > 0 || isScreenshot) && (!blurredFB.isAllocated() || firstRender))) {
-
         if (firstRender)
             firstRender = false;
 
@@ -204,9 +217,7 @@ bool CBackground::draw(const SRenderData& data) {
 
     return fade || data.opacity < 1.0; // actively render during fading
 }
-
 void CBackground::plantReloadTimer() {
-
     if (reloadTime == 0)
         reloadTimer = g_pHyprlock->addTimer(std::chrono::hours(1), [REF = m_self](auto, auto) { onReloadTimer(REF); }, nullptr, true);
     else if (reloadTime > 0)
@@ -214,9 +225,7 @@ void CBackground::plantReloadTimer() {
 }
 
 void CBackground::onCrossFadeTimerUpdate() {
-
     // Animation done: Unload previous asset, deinitialize the fade and pass the asset
-
     if (fade) {
         fade->crossFadeTimer.reset();
         fade.reset();
@@ -238,7 +247,6 @@ void CBackground::onReloadTimerUpdate() {
     const std::string OLDPATH = path;
 
     // Path parsing and early returns
-
     if (!reloadCommand.empty()) {
         path = g_pHyprlock->spawnSync(reloadCommand);
 
@@ -252,6 +260,10 @@ void CBackground::onReloadTimerUpdate() {
             return;
     }
 
+    // Skip reload for video backgrounds
+    if (isVideoBackground)
+        return;
+
     try {
         const auto MTIME = std::filesystem::last_write_time(absolutePath(path, ""));
         if (OLDPATH == path && MTIME == modificationTime)
@@ -268,7 +280,6 @@ void CBackground::onReloadTimerUpdate() {
         return;
 
     // Issue the next request
-
     request.id        = std::string{"background:"} + path + ",time:" + std::to_string((uint64_t)modificationTime.time_since_epoch().count());
     pendingResourceID = request.id;
     request.asset     = path;
@@ -292,7 +303,7 @@ void CBackground::startCrossFadeOrUpdateRender() {
                 if (!fade)
                     fade = makeUnique<SFade>(std::chrono::system_clock::now(), 0, nullptr);
                 else {
-                    // Maybe we where already fading so reset it just in case, but should'nt be happening.
+                    // Maybe we were already fading so reset it just in case, but shouldn't be happening.
                     if (fade->crossFadeTimer) {
                         fade->crossFadeTimer->cancel();
                         fade->crossFadeTimer.reset();
@@ -312,4 +323,4 @@ void CBackground::startCrossFadeOrUpdateRender() {
     }
 
     g_pHyprlock->renderOutput(outputPort);
-}
+}
\ No newline at end of file

From eb28b37e14d820db83f6727bb211b22a9242f0af Mon Sep 17 00:00:00 2001
From: RAMA <70065309+nomadxxxx@users.noreply.github.com>
Date: Mon, 7 Apr 2025 16:09:19 +1000
Subject: [PATCH 2/4] update

---
 src/config/ConfigManager.cpp        | 841 ++++++++++++++--------------
 src/renderer/widgets/Background.hpp |   6 +-
 2 files changed, 425 insertions(+), 422 deletions(-)

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 5995f5e5..01391c4f 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -201,437 +201,436 @@ inline static constexpr auto GRADIENTCONFIG = [](const char* default_value) -> H
 inline static constexpr auto LAYOUTCONFIG = [](const char* default_value) -> Hyprlang::CUSTOMTYPE {
     return Hyprlang::CUSTOMTYPE{&configHandleLayoutOption, configHandleLayoutOptionDestroy, default_value};
 };
-
 void CConfigManager::init() {
 
-#define SHADOWABLE(name)                                                                                                                                                           \
-    m_config.addSpecialConfigValue(name, "shadow_size", Hyprlang::INT{3});                                                                                                         \
-    m_config.addSpecialConfigValue(name, "shadow_passes", Hyprlang::INT{0});                                                                                                       \
-    m_config.addSpecialConfigValue(name, "shadow_color", Hyprlang::INT{0xFF000000});                                                                                               \
-    m_config.addSpecialConfigValue(name, "shadow_boost", Hyprlang::FLOAT{1.2});
-    m_config.addConfigValue("general:text_trim", Hyprlang::INT{1});
-    m_config.addConfigValue("general:hide_cursor", Hyprlang::INT{0});
-    m_config.addConfigValue("general:grace", Hyprlang::INT{0});
-    m_config.addConfigValue("general:ignore_empty_input", Hyprlang::INT{0});
-    m_config.addConfigValue("general:immediate_render", Hyprlang::INT{0});
-    m_config.addConfigValue("general:fractional_scaling", Hyprlang::INT{2});
-    m_config.addConfigValue("general:screencopy_mode", Hyprlang::INT{0});
-    m_config.addConfigValue("general:fail_timeout", Hyprlang::INT{2000});
-
-    m_config.addConfigValue("auth:pam:enabled", Hyprlang::INT{1});
-    m_config.addConfigValue("auth:pam:module", Hyprlang::STRING{"hyprlock"});
-    m_config.addConfigValue("auth:fingerprint:enabled", Hyprlang::INT{0});
-    m_config.addConfigValue("auth:fingerprint:ready_message", Hyprlang::STRING{"(Scan fingerprint to unlock)"});
-    m_config.addConfigValue("auth:fingerprint:present_message", Hyprlang::STRING{"Scanning fingerprint"});
-    m_config.addConfigValue("auth:fingerprint:retry_delay", Hyprlang::INT{250});
-
-    m_config.addConfigValue("animations:enabled", Hyprlang::INT{1});
-
-    m_config.addSpecialCategory("background", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
-    m_config.addSpecialConfigValue("background", "monitor", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("background", "path", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("background", "color", Hyprlang::INT{0xFF111111});
-    m_config.addSpecialConfigValue("background", "blur_size", Hyprlang::INT{8});
-    m_config.addSpecialConfigValue("background", "blur_passes", Hyprlang::INT{0});
-    m_config.addSpecialConfigValue("background", "noise", Hyprlang::FLOAT{0.0117});
-    m_config.addSpecialConfigValue("background", "contrast", Hyprlang::FLOAT{0.8917});
-    m_config.addSpecialConfigValue("background", "brightness", Hyprlang::FLOAT{0.8172});
-    m_config.addSpecialConfigValue("background", "vibrancy", Hyprlang::FLOAT{0.1686});
-    m_config.addSpecialConfigValue("background", "vibrancy_darkness", Hyprlang::FLOAT{0.05});
-    m_config.addSpecialConfigValue("background", "zindex", Hyprlang::INT{-1});
-    m_config.addSpecialConfigValue("background", "reload_time", Hyprlang::INT{-1});
-    m_config.addSpecialConfigValue("background", "reload_cmd", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("background", "crossfade_time", Hyprlang::FLOAT{-1.0});
-
-    m_config.addSpecialCategory("shape", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
-    m_config.addSpecialConfigValue("shape", "monitor", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("shape", "size", LAYOUTCONFIG("100,100"));
-    m_config.addSpecialConfigValue("shape", "rounding", Hyprlang::INT{0});
-    m_config.addSpecialConfigValue("shape", "border_size", Hyprlang::INT{0});
-    m_config.addSpecialConfigValue("shape", "border_color", GRADIENTCONFIG("0xFF00CFE6"));
-    m_config.addSpecialConfigValue("shape", "color", Hyprlang::INT{0xFF111111});
-    m_config.addSpecialConfigValue("shape", "position", LAYOUTCONFIG("0,0"));
-    m_config.addSpecialConfigValue("shape", "halign", Hyprlang::STRING{"center"});
-    m_config.addSpecialConfigValue("shape", "valign", Hyprlang::STRING{"center"});
-    m_config.addSpecialConfigValue("shape", "rotate", Hyprlang::FLOAT{0});
-    m_config.addSpecialConfigValue("shape", "xray", Hyprlang::INT{0});
-    m_config.addSpecialConfigValue("shape", "zindex", Hyprlang::INT{0});
-    SHADOWABLE("shape");
-
-    m_config.addSpecialCategory("image", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
-    m_config.addSpecialConfigValue("image", "monitor", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("image", "path", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("image", "size", Hyprlang::INT{150});
-    m_config.addSpecialConfigValue("image", "rounding", Hyprlang::INT{-1});
-    m_config.addSpecialConfigValue("image", "border_size", Hyprlang::INT{4});
-    m_config.addSpecialConfigValue("image", "border_color", GRADIENTCONFIG("0xFFDDDDDD"));
-    m_config.addSpecialConfigValue("image", "position", LAYOUTCONFIG("0,0"));
-    m_config.addSpecialConfigValue("image", "halign", Hyprlang::STRING{"center"});
-    m_config.addSpecialConfigValue("image", "valign", Hyprlang::STRING{"center"});
-    m_config.addSpecialConfigValue("image", "rotate", Hyprlang::FLOAT{0});
-    m_config.addSpecialConfigValue("image", "reload_time", Hyprlang::INT{-1});
-    m_config.addSpecialConfigValue("image", "reload_cmd", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("image", "zindex", Hyprlang::INT{0});
-    SHADOWABLE("image");
-
-    m_config.addSpecialCategory("input-field", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
-    m_config.addSpecialConfigValue("input-field", "monitor", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("input-field", "size", LAYOUTCONFIG("400,90"));
-    m_config.addSpecialConfigValue("input-field", "inner_color", Hyprlang::INT{0xFFDDDDDD});
-    m_config.addSpecialConfigValue("input-field", "outer_color", GRADIENTCONFIG("0xFF111111"));
-    m_config.addSpecialConfigValue("input-field", "outline_thickness", Hyprlang::INT{4});
-    m_config.addSpecialConfigValue("input-field", "dots_size", Hyprlang::FLOAT{0.25});
-    m_config.addSpecialConfigValue("input-field", "dots_center", Hyprlang::INT{1});
-    m_config.addSpecialConfigValue("input-field", "dots_spacing", Hyprlang::FLOAT{0.2});
-    m_config.addSpecialConfigValue("input-field", "dots_rounding", Hyprlang::INT{-1});
-    m_config.addSpecialConfigValue("input-field", "dots_text_format", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("input-field", "fade_on_empty", Hyprlang::INT{1});
-    m_config.addSpecialConfigValue("input-field", "fade_timeout", Hyprlang::INT{2000});
-    m_config.addSpecialConfigValue("input-field", "font_color", Hyprlang::INT{0xFF000000});
-    m_config.addSpecialConfigValue("input-field", "font_family", Hyprlang::STRING{"Sans"});
-    m_config.addSpecialConfigValue("input-field", "halign", Hyprlang::STRING{"center"});
-    m_config.addSpecialConfigValue("input-field", "valign", Hyprlang::STRING{"center"});
-    m_config.addSpecialConfigValue("input-field", "position", LAYOUTCONFIG("0,0"));
-    m_config.addSpecialConfigValue("input-field", "placeholder_text", Hyprlang::STRING{"<i>Input Password</i>"});
-    m_config.addSpecialConfigValue("input-field", "hide_input", Hyprlang::INT{0});
-    m_config.addSpecialConfigValue("input-field", "hide_input_base_color", Hyprlang::INT{0xEE00FF99});
-    m_config.addSpecialConfigValue("input-field", "rounding", Hyprlang::INT{-1});
-    m_config.addSpecialConfigValue("input-field", "check_color", GRADIENTCONFIG("0xFF22CC88"));
-    m_config.addSpecialConfigValue("input-field", "fail_color", GRADIENTCONFIG("0xFFCC2222"));
-    m_config.addSpecialConfigValue("input-field", "fail_text", Hyprlang::STRING{"<i>$FAIL</i>"});
-    m_config.addSpecialConfigValue("input-field", "capslock_color", GRADIENTCONFIG(""));
-    m_config.addSpecialConfigValue("input-field", "numlock_color", GRADIENTCONFIG(""));
-    m_config.addSpecialConfigValue("input-field", "bothlock_color", GRADIENTCONFIG(""));
-    m_config.addSpecialConfigValue("input-field", "invert_numlock", Hyprlang::INT{0});
-    m_config.addSpecialConfigValue("input-field", "swap_font_color", Hyprlang::INT{0});
-    m_config.addSpecialConfigValue("input-field", "zindex", Hyprlang::INT{0});
-    SHADOWABLE("input-field");
-
-    m_config.addSpecialCategory("label", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
-    m_config.addSpecialConfigValue("label", "monitor", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("label", "position", LAYOUTCONFIG("0,0"));
-    m_config.addSpecialConfigValue("label", "color", Hyprlang::INT{0xFFFFFFFF});
-    m_config.addSpecialConfigValue("label", "font_size", Hyprlang::INT{16});
-    m_config.addSpecialConfigValue("label", "text", Hyprlang::STRING{"Sample Text"});
-    m_config.addSpecialConfigValue("label", "font_family", Hyprlang::STRING{"Sans"});
-    m_config.addSpecialConfigValue("label", "halign", Hyprlang::STRING{"none"});
-    m_config.addSpecialConfigValue("label", "valign", Hyprlang::STRING{"none"});
-    m_config.addSpecialConfigValue("label", "rotate", Hyprlang::FLOAT{0});
-    m_config.addSpecialConfigValue("label", "text_align", Hyprlang::STRING{""});
-    m_config.addSpecialConfigValue("label", "zindex", Hyprlang::INT{0});
-    SHADOWABLE("label");
-
-    m_config.registerHandler(&::handleSource, "source", {.allowFlags = false});
-    m_config.registerHandler(&::handleBezier, "bezier", {.allowFlags = false});
-    m_config.registerHandler(&::handleAnimation, "animation", {.allowFlags = false});
-
-    //
-    // Init Animations
-    //
-    m_AnimationTree.createNode("global");
-
-    // toplevel
-    m_AnimationTree.createNode("fade", "global");
-    m_AnimationTree.createNode("inputField", "global");
-
-    // inputField
-    m_AnimationTree.createNode("inputFieldColors", "inputField");
-    m_AnimationTree.createNode("inputFieldFade", "inputField");
-    m_AnimationTree.createNode("inputFieldWidth", "inputField");
-    m_AnimationTree.createNode("inputFieldDots", "inputField");
-
-    // fade
-    m_AnimationTree.createNode("fadeIn", "fade");
-    m_AnimationTree.createNode("fadeOut", "fade");
-
-    // set config for root node
-    m_AnimationTree.setConfigForNode("global", 1, 8.f, "default");
-    m_AnimationTree.setConfigForNode("inputFieldColors", 1, 8.f, "linear");
-
-    m_config.commence();
-
-    auto result = m_config.parse();
-
-    if (result.error)
-        Debug::log(ERR, "Config has errors:\n{}\nProceeding ignoring faulty entries", result.getError());
-
-#undef SHADOWABLE
-}
-
-std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
-    std::vector<CConfigManager::SWidgetConfig> result;
-
-#define SHADOWABLE(name)                                                                                                                                                           \
-    {"shadow_size", m_config.getSpecialConfigValue(name, "shadow_size", k.c_str())}, {"shadow_passes", m_config.getSpecialConfigValue(name, "shadow_passes", k.c_str())},          \
-        {"shadow_color", m_config.getSpecialConfigValue(name, "shadow_color", k.c_str())}, {                                                                                       \
-        "shadow_boost", m_config.getSpecialConfigValue(name, "shadow_boost", k.c_str())                                                                                            \
-    }
-
-    //
-    auto keys = m_config.listKeysForSpecialCategory("background");
-    result.reserve(keys.size());
-    for (auto& k : keys) {
-        // clang-format off
-        result.push_back(CConfigManager::SWidgetConfig{
-            .type = "background",
-            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("background", "monitor", k.c_str())),
-            .values = {
-                {"path", m_config.getSpecialConfigValue("background", "path", k.c_str())},
-                {"color", m_config.getSpecialConfigValue("background", "color", k.c_str())},
-                {"blur_size", m_config.getSpecialConfigValue("background", "blur_size", k.c_str())},
-                {"blur_passes", m_config.getSpecialConfigValue("background", "blur_passes", k.c_str())},
-                {"noise", m_config.getSpecialConfigValue("background", "noise", k.c_str())},
-                {"contrast", m_config.getSpecialConfigValue("background", "contrast", k.c_str())},
-                {"vibrancy", m_config.getSpecialConfigValue("background", "vibrancy", k.c_str())},
-                {"brightness", m_config.getSpecialConfigValue("background", "brightness", k.c_str())},
-                {"vibrancy_darkness", m_config.getSpecialConfigValue("background", "vibrancy_darkness", k.c_str())},
-                {"zindex", m_config.getSpecialConfigValue("background", "zindex", k.c_str())},
-                {"reload_time", m_config.getSpecialConfigValue("background", "reload_time", k.c_str())},
-                {"reload_cmd", m_config.getSpecialConfigValue("background", "reload_cmd", k.c_str())},
-                {"crossfade_time", m_config.getSpecialConfigValue("background", "crossfade_time", k.c_str())},
-            }
-        });
-        // clang-format on
-    }
-
-    //
-    keys = m_config.listKeysForSpecialCategory("shape");
-    for (auto& k : keys) {
-        // clang-format off
-        result.push_back(CConfigManager::SWidgetConfig{
-            .type = "shape",
-            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("shape", "monitor", k.c_str())),
-            .values = {
-                {"size", m_config.getSpecialConfigValue("shape", "size", k.c_str())},
-                {"rounding", m_config.getSpecialConfigValue("shape", "rounding", k.c_str())},
-                {"border_size", m_config.getSpecialConfigValue("shape", "border_size", k.c_str())},
-                {"border_color", m_config.getSpecialConfigValue("shape", "border_color", k.c_str())},
-                {"color", m_config.getSpecialConfigValue("shape", "color", k.c_str())},
-                {"position", m_config.getSpecialConfigValue("shape", "position", k.c_str())},
-                {"halign", m_config.getSpecialConfigValue("shape", "halign", k.c_str())},
-                {"valign", m_config.getSpecialConfigValue("shape", "valign", k.c_str())},
-                {"rotate", m_config.getSpecialConfigValue("shape", "rotate", k.c_str())},
-                {"xray", m_config.getSpecialConfigValue("shape", "xray", k.c_str())},
-                {"zindex", m_config.getSpecialConfigValue("shape", "zindex", k.c_str())},
-                SHADOWABLE("shape"),
-            }
-        });
-        // clang-format on
-    }
-
-    //
-    keys = m_config.listKeysForSpecialCategory("image");
-    for (auto& k : keys) {
-        // clang-format off
-        result.push_back(CConfigManager::SWidgetConfig{
-            .type = "image",
-            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("image", "monitor", k.c_str())),
-            .values = {
-                {"path", m_config.getSpecialConfigValue("image", "path", k.c_str())},
-                {"size", m_config.getSpecialConfigValue("image", "size", k.c_str())},
-                {"rounding", m_config.getSpecialConfigValue("image", "rounding", k.c_str())},
-                {"border_size", m_config.getSpecialConfigValue("image", "border_size", k.c_str())},
-                {"border_color", m_config.getSpecialConfigValue("image", "border_color", k.c_str())},
-                {"position", m_config.getSpecialConfigValue("image", "position", k.c_str())},
-                {"halign", m_config.getSpecialConfigValue("image", "halign", k.c_str())},
-                {"valign", m_config.getSpecialConfigValue("image", "valign", k.c_str())},
-                {"rotate", m_config.getSpecialConfigValue("image", "rotate", k.c_str())},
-                {"reload_time", m_config.getSpecialConfigValue("image", "reload_time", k.c_str())},
-                {"reload_cmd", m_config.getSpecialConfigValue("image", "reload_cmd", k.c_str())},
-                {"zindex", m_config.getSpecialConfigValue("image", "zindex", k.c_str())},
-                SHADOWABLE("image"),
-            }
-        });
-        // clang-format on
-    }
-
-    keys = m_config.listKeysForSpecialCategory("input-field");
-    for (auto& k : keys) {
-        // clang-format off
-        result.push_back(CConfigManager::SWidgetConfig{
-            .type = "input-field",
-            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("input-field", "monitor", k.c_str())),
-            .values = {
-                {"size", m_config.getSpecialConfigValue("input-field", "size", k.c_str())},
-                {"inner_color", m_config.getSpecialConfigValue("input-field", "inner_color", k.c_str())},
-                {"outer_color", m_config.getSpecialConfigValue("input-field", "outer_color", k.c_str())},
-                {"outline_thickness", m_config.getSpecialConfigValue("input-field", "outline_thickness", k.c_str())},
-                {"dots_size", m_config.getSpecialConfigValue("input-field", "dots_size", k.c_str())},
-                {"dots_spacing", m_config.getSpecialConfigValue("input-field", "dots_spacing", k.c_str())},
-                {"dots_center", m_config.getSpecialConfigValue("input-field", "dots_center", k.c_str())},
-                {"dots_rounding", m_config.getSpecialConfigValue("input-field", "dots_rounding", k.c_str())},
-                {"dots_text_format", m_config.getSpecialConfigValue("input-field", "dots_text_format", k.c_str())},
-                {"fade_on_empty", m_config.getSpecialConfigValue("input-field", "fade_on_empty", k.c_str())},
-                {"fade_timeout", m_config.getSpecialConfigValue("input-field", "fade_timeout", k.c_str())},
-                {"font_color", m_config.getSpecialConfigValue("input-field", "font_color", k.c_str())},
-                {"font_family", m_config.getSpecialConfigValue("input-field", "font_family", k.c_str())},
-                {"halign", m_config.getSpecialConfigValue("input-field", "halign", k.c_str())},
-                {"valign", m_config.getSpecialConfigValue("input-field", "valign", k.c_str())},
-                {"position", m_config.getSpecialConfigValue("input-field", "position", k.c_str())},
-                {"placeholder_text", m_config.getSpecialConfigValue("input-field", "placeholder_text", k.c_str())},
-                {"hide_input", m_config.getSpecialConfigValue("input-field", "hide_input", k.c_str())},
-                {"hide_input_base_color", m_config.getSpecialConfigValue("input-field", "hide_input_base_color", k.c_str())},
-                {"rounding", m_config.getSpecialConfigValue("input-field", "rounding", k.c_str())},
-                {"check_color", m_config.getSpecialConfigValue("input-field", "check_color", k.c_str())},
-                {"fail_color", m_config.getSpecialConfigValue("input-field", "fail_color", k.c_str())},
-                {"fail_text", m_config.getSpecialConfigValue("input-field", "fail_text", k.c_str())},
-                {"capslock_color", m_config.getSpecialConfigValue("input-field", "capslock_color", k.c_str())},
-                {"numlock_color", m_config.getSpecialConfigValue("input-field", "numlock_color", k.c_str())},
-                {"bothlock_color", m_config.getSpecialConfigValue("input-field", "bothlock_color", k.c_str())},
-                {"invert_numlock", m_config.getSpecialConfigValue("input-field", "invert_numlock", k.c_str())},
-                {"swap_font_color", m_config.getSpecialConfigValue("input-field", "swap_font_color", k.c_str())},
-                {"zindex", m_config.getSpecialConfigValue("input-field", "zindex", k.c_str())},
-                SHADOWABLE("input-field"),
-            }
-        });
-        // clang-format on
-    }
-
-    keys = m_config.listKeysForSpecialCategory("label");
-    for (auto& k : keys) {
-        // clang-format off
-        result.push_back(CConfigManager::SWidgetConfig{
-            .type = "label",
-            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("label", "monitor", k.c_str())),
-            .values = {
-                {"position", m_config.getSpecialConfigValue("label", "position", k.c_str())},
-                {"color", m_config.getSpecialConfigValue("label", "color", k.c_str())},
-                {"font_size", m_config.getSpecialConfigValue("label", "font_size", k.c_str())},
-                {"font_family", m_config.getSpecialConfigValue("label", "font_family", k.c_str())},
-                {"text", m_config.getSpecialConfigValue("label", "text", k.c_str())},
-                {"halign", m_config.getSpecialConfigValue("label", "halign", k.c_str())},
-                {"valign", m_config.getSpecialConfigValue("label", "valign", k.c_str())},
-                {"rotate", m_config.getSpecialConfigValue("label", "rotate", k.c_str())},
-                {"text_align", m_config.getSpecialConfigValue("label", "text_align", k.c_str())},
-                {"zindex", m_config.getSpecialConfigValue("label", "zindex", k.c_str())},
-                SHADOWABLE("label"),
-            }
-        });
-        // clang-format on
-    }
-
-    return result;
-}
-
-std::optional<std::string> CConfigManager::handleSource(const std::string& command, const std::string& rawpath) {
-    if (rawpath.length() < 2) {
-        Debug::log(ERR, "source= path garbage");
-        return "source path " + rawpath + " bogus!";
+    #define SHADOWABLE(name)                                                                                                                                                           \
+        m_config.addSpecialConfigValue(name, "shadow_size", Hyprlang::INT{3});                                                                                                         \
+        m_config.addSpecialConfigValue(name, "shadow_passes", Hyprlang::INT{0});                                                                                                       \
+        m_config.addSpecialConfigValue(name, "shadow_color", Hyprlang::INT{0xFF000000});                                                                                               \
+        m_config.addSpecialConfigValue(name, "shadow_boost", Hyprlang::FLOAT{1.2});
+        m_config.addConfigValue("general:text_trim", Hyprlang::INT{1});
+        m_config.addConfigValue("general:hide_cursor", Hyprlang::INT{0});
+        m_config.addConfigValue("general:grace", Hyprlang::INT{0});
+        m_config.addConfigValue("general:ignore_empty_input", Hyprlang::INT{0});
+        m_config.addConfigValue("general:immediate_render", Hyprlang::INT{0});
+        m_config.addConfigValue("general:fractional_scaling", Hyprlang::INT{2});
+        m_config.addConfigValue("general:screencopy_mode", Hyprlang::INT{0});
+        m_config.addConfigValue("general:fail_timeout", Hyprlang::INT{2000});
+    
+        m_config.addConfigValue("auth:pam:enabled", Hyprlang::INT{1});
+        m_config.addConfigValue("auth:pam:module", Hyprlang::STRING{"hyprlock"});
+        m_config.addConfigValue("auth:fingerprint:enabled", Hyprlang::INT{0});
+        m_config.addConfigValue("auth:fingerprint:ready_message", Hyprlang::STRING{"(Scan fingerprint to unlock)"});
+        m_config.addConfigValue("auth:fingerprint:present_message", Hyprlang::STRING{"Scanning fingerprint"});
+        m_config.addConfigValue("auth:fingerprint:retry_delay", Hyprlang::INT{250});
+    
+        m_config.addConfigValue("animations:enabled", Hyprlang::INT{1});
+    
+        m_config.addSpecialCategory("background", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
+        m_config.addSpecialConfigValue("background", "monitor", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("background", "type", Hyprlang::STRING{"image"});  // New type field
+        m_config.addSpecialConfigValue("background", "path", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("background", "color", Hyprlang::INT{0xFF111111});
+        m_config.addSpecialConfigValue("background", "blur_size", Hyprlang::INT{8});
+        m_config.addSpecialConfigValue("background", "blur_passes", Hyprlang::INT{0});
+        m_config.addSpecialConfigValue("background", "noise", Hyprlang::FLOAT{0.0117});
+        m_config.addSpecialConfigValue("background", "contrast", Hyprlang::FLOAT{0.8917});
+        m_config.addSpecialConfigValue("background", "brightness", Hyprlang::FLOAT{0.8172});
+        m_config.addSpecialConfigValue("background", "vibrancy", Hyprlang::FLOAT{0.1686});
+        m_config.addSpecialConfigValue("background", "vibrancy_darkness", Hyprlang::FLOAT{0.05});
+        m_config.addSpecialConfigValue("background", "zindex", Hyprlang::INT{-1});
+        m_config.addSpecialConfigValue("background", "reload_time", Hyprlang::INT{-1});
+        m_config.addSpecialConfigValue("background", "reload_cmd", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("background", "crossfade_time", Hyprlang::FLOAT{-1.0});
+    
+        m_config.addSpecialCategory("shape", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
+        m_config.addSpecialConfigValue("shape", "monitor", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("shape", "size", LAYOUTCONFIG("100,100"));
+        m_config.addSpecialConfigValue("shape", "rounding", Hyprlang::INT{0});
+        m_config.addSpecialConfigValue("shape", "border_size", Hyprlang::INT{0});
+        m_config.addSpecialConfigValue("shape", "border_color", GRADIENTCONFIG("0xFF00CFE6"));
+        m_config.addSpecialConfigValue("shape", "color", Hyprlang::INT{0xFF111111});
+        m_config.addSpecialConfigValue("shape", "position", LAYOUTCONFIG("0,0"));
+        m_config.addSpecialConfigValue("shape", "halign", Hyprlang::STRING{"center"});
+        m_config.addSpecialConfigValue("shape", "valign", Hyprlang::STRING{"center"});
+        m_config.addSpecialConfigValue("shape", "rotate", Hyprlang::FLOAT{0});
+        m_config.addSpecialConfigValue("shape", "xray", Hyprlang::INT{0});
+        m_config.addSpecialConfigValue("shape", "zindex", Hyprlang::INT{0});
+        SHADOWABLE("shape");
+    
+        m_config.addSpecialCategory("image", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
+        m_config.addSpecialConfigValue("image", "monitor", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("image", "path", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("image", "size", Hyprlang::INT{150});
+        m_config.addSpecialConfigValue("image", "rounding", Hyprlang::INT{-1});
+        m_config.addSpecialConfigValue("image", "border_size", Hyprlang::INT{4});
+        m_config.addSpecialConfigValue("image", "border_color", GRADIENTCONFIG("0xFFDDDDDD"));
+        m_config.addSpecialConfigValue("image", "position", LAYOUTCONFIG("0,0"));
+        m_config.addSpecialConfigValue("image", "halign", Hyprlang::STRING{"center"});
+        m_config.addSpecialConfigValue("image", "valign", Hyprlang::STRING{"center"});
+        m_config.addSpecialConfigValue("image", "rotate", Hyprlang::FLOAT{0});
+        m_config.addSpecialConfigValue("image", "reload_time", Hyprlang::INT{-1});
+        m_config.addSpecialConfigValue("image", "reload_cmd", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("image", "zindex", Hyprlang::INT{0});
+        SHADOWABLE("image");
+    
+        m_config.addSpecialCategory("input-field", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
+        m_config.addSpecialConfigValue("input-field", "monitor", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("input-field", "size", LAYOUTCONFIG("400,90"));
+        m_config.addSpecialConfigValue("input-field", "inner_color", Hyprlang::INT{0xFFDDDDDD});
+        m_config.addSpecialConfigValue("input-field", "outer_color", GRADIENTCONFIG("0xFF111111"));
+        m_config.addSpecialConfigValue("input-field", "outline_thickness", Hyprlang::INT{4});
+        m_config.addSpecialConfigValue("input-field", "dots_size", Hyprlang::FLOAT{0.25});
+        m_config.addSpecialConfigValue("input-field", "dots_center", Hyprlang::INT{1});
+        m_config.addSpecialConfigValue("input-field", "dots_spacing", Hyprlang::FLOAT{0.2});
+        m_config.addSpecialConfigValue("input-field", "dots_rounding", Hyprlang::INT{-1});
+        m_config.addSpecialConfigValue("input-field", "dots_text_format", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("input-field", "fade_on_empty", Hyprlang::INT{1});
+        m_config.addSpecialConfigValue("input-field", "fade_timeout", Hyprlang::INT{2000});
+        m_config.addSpecialConfigValue("input-field", "font_color", Hyprlang::INT{0xFF000000});
+        m_config.addSpecialConfigValue("input-field", "font_family", Hyprlang::STRING{"Sans"});
+        m_config.addSpecialConfigValue("input-field", "halign", Hyprlang::STRING{"center"});
+        m_config.addSpecialConfigValue("input-field", "valign", Hyprlang::STRING{"center"});
+        m_config.addSpecialConfigValue("input-field", "position", LAYOUTCONFIG("0,0"));
+        m_config.addSpecialConfigValue("input-field", "placeholder_text", Hyprlang::STRING{"<i>Input Password</i>"});
+        m_config.addSpecialConfigValue("input-field", "hide_input", Hyprlang::INT{0});
+        m_config.addSpecialConfigValue("input-field", "hide_input_base_color", Hyprlang::INT{0xEE00FF99});
+        m_config.addSpecialConfigValue("input-field", "rounding", Hyprlang::INT{-1});
+        m_config.addSpecialConfigValue("input-field", "check_color", GRADIENTCONFIG("0xFF22CC88"));
+        m_config.addSpecialConfigValue("input-field", "fail_color", GRADIENTCONFIG("0xFFCC2222"));
+        m_config.addSpecialConfigValue("input-field", "fail_text", Hyprlang::STRING{"<i>$FAIL</i>"});
+        m_config.addSpecialConfigValue("input-field", "capslock_color", GRADIENTCONFIG(""));
+        m_config.addSpecialConfigValue("input-field", "numlock_color", GRADIENTCONFIG(""));
+        m_config.addSpecialConfigValue("input-field", "bothlock_color", GRADIENTCONFIG(""));
+        m_config.addSpecialConfigValue("input-field", "invert_numlock", Hyprlang::INT{0});
+        m_config.addSpecialConfigValue("input-field", "swap_font_color", Hyprlang::INT{0});
+        m_config.addSpecialConfigValue("input-field", "zindex", Hyprlang::INT{0});
+        SHADOWABLE("input-field");
+    
+        m_config.addSpecialCategory("label", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
+        m_config.addSpecialConfigValue("label", "monitor", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("label", "position", LAYOUTCONFIG("0,0"));
+        m_config.addSpecialConfigValue("label", "color", Hyprlang::INT{0xFFFFFFFF});
+        m_config.addSpecialConfigValue("label", "font_size", Hyprlang::INT{16});
+        m_config.addSpecialConfigValue("label", "text", Hyprlang::STRING{"Sample Text"});
+        m_config.addSpecialConfigValue("label", "font_family", Hyprlang::STRING{"Sans"});
+        m_config.addSpecialConfigValue("label", "halign", Hyprlang::STRING{"none"});
+        m_config.addSpecialConfigValue("label", "valign", Hyprlang::STRING{"none"});
+        m_config.addSpecialConfigValue("label", "rotate", Hyprlang::FLOAT{0});
+        m_config.addSpecialConfigValue("label", "text_align", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("label", "zindex", Hyprlang::INT{0});
+        SHADOWABLE("label");
+    
+        m_config.registerHandler(&::handleSource, "source", {.allowFlags = false});
+        m_config.registerHandler(&::handleBezier, "bezier", {.allowFlags = false});
+        m_config.registerHandler(&::handleAnimation, "animation", {.allowFlags = false});
+    
+        //
+        // Init Animations
+        //
+        m_AnimationTree.createNode("global");
+    
+        // toplevel
+        m_AnimationTree.createNode("fade", "global");
+        m_AnimationTree.createNode("inputField", "global");
+    
+        // inputField
+        m_AnimationTree.createNode("inputFieldColors", "inputField");
+        m_AnimationTree.createNode("inputFieldFade", "inputField");
+        m_AnimationTree.createNode("inputFieldWidth", "inputField");
+        m_AnimationTree.createNode("inputFieldDots", "inputField");
+    
+        // fade
+        m_AnimationTree.createNode("fadeIn", "fade");
+        m_AnimationTree.createNode("fadeOut", "fade");
+    
+        // set config for root node
+        m_AnimationTree.setConfigForNode("global", 1, 8.f, "default");
+        m_AnimationTree.setConfigForNode("inputFieldColors", 1, 8.f, "linear");
+    
+        m_config.commence();
+    
+        auto result = m_config.parse();
+    
+        if (result.error)
+            Debug::log(ERR, "Config has errors:\n{}\nProceeding ignoring faulty entries", result.getError());
+    
+    #undef SHADOWABLE
     }
-    std::unique_ptr<glob_t, void (*)(glob_t*)> glob_buf{new glob_t, [](glob_t* g) { globfree(g); }};
-    memset(glob_buf.get(), 0, sizeof(glob_t));
-
-    const auto CURRENTDIR = std::filesystem::path(configCurrentPath).parent_path().string();
-
-    if (auto r = glob(absolutePath(rawpath, CURRENTDIR).c_str(), GLOB_TILDE, nullptr, glob_buf.get()); r != 0) {
-        std::string err = std::format("source= globbing error: {}", r == GLOB_NOMATCH ? "found no match" : GLOB_ABORTED ? "read error" : "out of memory");
-        Debug::log(ERR, "{}", err);
-        return err;
+    std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
+        std::vector<CConfigManager::SWidgetConfig> result;
+    
+    #define SHADOWABLE(name)                                                                                                                                                           \
+        {"shadow_size", m_config.getSpecialConfigValue(name, "shadow_size", k.c_str())}, {"shadow_passes", m_config.getSpecialConfigValue(name, "shadow_passes", k.c_str())},          \
+            {"shadow_color", m_config.getSpecialConfigValue(name, "shadow_color", k.c_str())}, {                                                                                       \
+            "shadow_boost", m_config.getSpecialConfigValue(name, "shadow_boost", k.c_str())                                                                                            \
+        }
+    
+        //
+        auto keys = m_config.listKeysForSpecialCategory("background");
+        result.reserve(keys.size());
+        for (auto& k : keys) {
+            // clang-format off
+            result.push_back(CConfigManager::SWidgetConfig{
+                .type = "background",
+                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("background", "monitor", k.c_str())),
+                .values = {
+                    {"type", m_config.getSpecialConfigValue("background", "type", k.c_str())},  // New type field
+                    {"path", m_config.getSpecialConfigValue("background", "path", k.c_str())},
+                    {"color", m_config.getSpecialConfigValue("background", "color", k.c_str())},
+                    {"blur_size", m_config.getSpecialConfigValue("background", "blur_size", k.c_str())},
+                    {"blur_passes", m_config.getSpecialConfigValue("background", "blur_passes", k.c_str())},
+                    {"noise", m_config.getSpecialConfigValue("background", "noise", k.c_str())},
+                    {"contrast", m_config.getSpecialConfigValue("background", "contrast", k.c_str())},
+                    {"vibrancy", m_config.getSpecialConfigValue("background", "vibrancy", k.c_str())},
+                    {"brightness", m_config.getSpecialConfigValue("background", "brightness", k.c_str())},
+                    {"vibrancy_darkness", m_config.getSpecialConfigValue("background", "vibrancy_darkness", k.c_str())},
+                    {"zindex", m_config.getSpecialConfigValue("background", "zindex", k.c_str())},
+                    {"reload_time", m_config.getSpecialConfigValue("background", "reload_time", k.c_str())},
+                    {"reload_cmd", m_config.getSpecialConfigValue("background", "reload_cmd", k.c_str())},
+                    {"crossfade_time", m_config.getSpecialConfigValue("background", "crossfade_time", k.c_str())},
+                }
+            });
+            // clang-format on
+        }
+    
+        //
+        keys = m_config.listKeysForSpecialCategory("shape");
+        for (auto& k : keys) {
+            // clang-format off
+            result.push_back(CConfigManager::SWidgetConfig{
+                .type = "shape",
+                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("shape", "monitor", k.c_str())),
+                .values = {
+                    {"size", m_config.getSpecialConfigValue("shape", "size", k.c_str())},
+                    {"rounding", m_config.getSpecialConfigValue("shape", "rounding", k.c_str())},
+                    {"border_size", m_config.getSpecialConfigValue("shape", "border_size", k.c_str())},
+                    {"border_color", m_config.getSpecialConfigValue("shape", "border_color", k.c_str())},
+                    {"color", m_config.getSpecialConfigValue("shape", "color", k.c_str())},
+                    {"position", m_config.getSpecialConfigValue("shape", "position", k.c_str())},
+                    {"halign", m_config.getSpecialConfigValue("shape", "halign", k.c_str())},
+                    {"valign", m_config.getSpecialConfigValue("shape", "valign", k.c_str())},
+                    {"rotate", m_config.getSpecialConfigValue("shape", "rotate", k.c_str())},
+                    {"xray", m_config.getSpecialConfigValue("shape", "xray", k.c_str())},
+                    {"zindex", m_config.getSpecialConfigValue("shape", "zindex", k.c_str())},
+                    SHADOWABLE("shape"),
+                }
+            });
+            // clang-format on
+        }
+    
+        //
+        keys = m_config.listKeysForSpecialCategory("image");
+        for (auto& k : keys) {
+            // clang-format off
+            result.push_back(CConfigManager::SWidgetConfig{
+                .type = "image",
+                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("image", "monitor", k.c_str())),
+                .values = {
+                    {"path", m_config.getSpecialConfigValue("image", "path", k.c_str())},
+                    {"size", m_config.getSpecialConfigValue("image", "size", k.c_str())},
+                    {"rounding", m_config.getSpecialConfigValue("image", "rounding", k.c_str())},
+                    {"border_size", m_config.getSpecialConfigValue("image", "border_size", k.c_str())},
+                    {"border_color", m_config.getSpecialConfigValue("image", "border_color", k.c_str())},
+                    {"position", m_config.getSpecialConfigValue("image", "position", k.c_str())},
+                    {"halign", m_config.getSpecialConfigValue("image", "halign", k.c_str())},
+                    {"valign", m_config.getSpecialConfigValue("image", "valign", k.c_str())},
+                    {"rotate", m_config.getSpecialConfigValue("image", "rotate", k.c_str())},
+                    {"reload_time", m_config.getSpecialConfigValue("image", "reload_time", k.c_str())},
+                    {"reload_cmd", m_config.getSpecialConfigValue("image", "reload_cmd", k.c_str())},
+                    {"zindex", m_config.getSpecialConfigValue("image", "zindex", k.c_str())},
+                    SHADOWABLE("image"),
+                }
+            });
+            // clang-format on
+        }
+    
+        keys = m_config.listKeysForSpecialCategory("input-field");
+        for (auto& k : keys) {
+            // clang-format off
+            result.push_back(CConfigManager::SWidgetConfig{
+                .type = "input-field",
+                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("input-field", "monitor", k.c_str())),
+                .values = {
+                    {"size", m_config.getSpecialConfigValue("input-field", "size", k.c_str())},
+                    {"inner_color", m_config.getSpecialConfigValue("input-field", "inner_color", k.c_str())},
+                    {"outer_color", m_config.getSpecialConfigValue("input-field", "outer_color", k.c_str())},
+                    {"outline_thickness", m_config.getSpecialConfigValue("input-field", "outline_thickness", k.c_str())},
+                    {"dots_size", m_config.getSpecialConfigValue("input-field", "dots_size", k.c_str())},
+                    {"dots_spacing", m_config.getSpecialConfigValue("input-field", "dots_spacing", k.c_str())},
+                    {"dots_center", m_config.getSpecialConfigValue("input-field", "dots_center", k.c_str())},
+                    {"dots_rounding", m_config.getSpecialConfigValue("input-field", "dots_rounding", k.c_str())},
+                    {"dots_text_format", m_config.getSpecialConfigValue("input-field", "dots_text_format", k.c_str())},
+                    {"fade_on_empty", m_config.getSpecialConfigValue("input-field", "fade_on_empty", k.c_str())},
+                    {"fade_timeout", m_config.getSpecialConfigValue("input-field", "fade_timeout", k.c_str())},
+                    {"font_color", m_config.getSpecialConfigValue("input-field", "font_color", k.c_str())},
+                    {"font_family", m_config.getSpecialConfigValue("input-field", "font_family", k.c_str())},
+                    {"halign", m_config.getSpecialConfigValue("input-field", "halign", k.c_str())},
+                    {"valign", m_config.getSpecialConfigValue("input-field", "valign", k.c_str())},
+                    {"position", m_config.getSpecialConfigValue("input-field", "position", k.c_str())},
+                    {"placeholder_text", m_config.getSpecialConfigValue("input-field", "placeholder_text", k.c_str())},
+                    {"hide_input", m_config.getSpecialConfigValue("input-field", "hide_input", k.c_str())},
+                    {"hide_input_base_color", m_config.getSpecialConfigValue("input-field", "hide_input_base_color", k.c_str())},
+                    {"rounding", m_config.getSpecialConfigValue("input-field", "rounding", k.c_str())},
+                    {"check_color", m_config.getSpecialConfigValue("input-field", "check_color", k.c_str())},
+                    {"fail_color", m_config.getSpecialConfigValue("input-field", "fail_color", k.c_str())},
+                    {"fail_text", m_config.getSpecialConfigValue("input-field", "fail_text", k.c_str())},
+                    {"capslock_color", m_config.getSpecialConfigValue("input-field", "capslock_color", k.c_str())},
+                    {"numlock_color", m_config.getSpecialConfigValue("input-field", "numlock_color", k.c_str())},
+                    {"bothlock_color", m_config.getSpecialConfigValue("input-field", "bothlock_color", k.c_str())},
+                    {"invert_numlock", m_config.getSpecialConfigValue("input-field", "invert_numlock", k.c_str())},
+                    {"swap_font_color", m_config.getSpecialConfigValue("input-field", "swap_font_color", k.c_str())},
+                    {"zindex", m_config.getSpecialConfigValue("input-field", "zindex", k.c_str())},
+                    SHADOWABLE("input-field"),
+                }
+            });
+            // clang-format on
+        }
+        keys = m_config.listKeysForSpecialCategory("label");
+        for (auto& k : keys) {
+            // clang-format off
+            result.push_back(CConfigManager::SWidgetConfig{
+                .type = "label",
+                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("label", "monitor", k.c_str())),
+                .values = {
+                    {"position", m_config.getSpecialConfigValue("label", "position", k.c_str())},
+                    {"color", m_config.getSpecialConfigValue("label", "color", k.c_str())},
+                    {"font_size", m_config.getSpecialConfigValue("label", "font_size", k.c_str())},
+                    {"font_family", m_config.getSpecialConfigValue("label", "font_family", k.c_str())},
+                    {"text", m_config.getSpecialConfigValue("label", "text", k.c_str())},
+                    {"halign", m_config.getSpecialConfigValue("label", "halign", k.c_str())},
+                    {"valign", m_config.getSpecialConfigValue("label", "valign", k.c_str())},
+                    {"rotate", m_config.getSpecialConfigValue("label", "rotate", k.c_str())},
+                    {"text_align", m_config.getSpecialConfigValue("label", "text_align", k.c_str())},
+                    {"zindex", m_config.getSpecialConfigValue("label", "zindex", k.c_str())},
+                    SHADOWABLE("label"),
+                }
+            });
+            // clang-format on
+        }
+    
+        return result;
     }
-
-    for (size_t i = 0; i < glob_buf->gl_pathc; i++) {
-        const auto PATH = absolutePath(glob_buf->gl_pathv[i], CURRENTDIR);
-
-        if (PATH.empty() || PATH == configCurrentPath) {
-            Debug::log(WARN, "source= skipping invalid path");
-            continue;
+    
+    std::optional<std::string> CConfigManager::handleSource(const std::string& command, const std::string& rawpath) {
+        if (rawpath.length() < 2) {
+            Debug::log(ERR, "source= path garbage");
+            return "source path " + rawpath + " bogus!";
         }
-
-        if (!std::filesystem::is_regular_file(PATH)) {
-            if (std::filesystem::exists(PATH)) {
-                Debug::log(WARN, "source= skipping non-file {}", PATH);
+        std::unique_ptr<glob_t, void (*)(glob_t*)> glob_buf{new glob_t, [](glob_t* g) { globfree(g); }};
+        memset(glob_buf.get(), 0, sizeof(glob_t));
+    
+        const auto CURRENTDIR = std::filesystem::path(configCurrentPath).parent_path().string();
+    
+        if (auto r = glob(absolutePath(rawpath, CURRENTDIR).c_str(), GLOB_TILDE, nullptr, glob_buf.get()); r != 0) {
+            std::string err = std::format("source= globbing error: {}", r == GLOB_NOMATCH ? "found no match" : GLOB_ABORTED ? "read error" : "out of memory");
+            Debug::log(ERR, "{}", err);
+            return err;
+        }
+    
+        for (size_t i = 0; i < glob_buf->gl_pathc; i++) {
+            const auto PATH = absolutePath(glob_buf->gl_pathv[i], CURRENTDIR);
+    
+            if (PATH.empty() || PATH == configCurrentPath) {
+                Debug::log(WARN, "source= skipping invalid path");
                 continue;
             }
-
-            Debug::log(ERR, "source= file doesnt exist");
-            return "source file " + PATH + " doesn't exist!";
+    
+            if (!std::filesystem::is_regular_file(PATH)) {
+                if (std::filesystem::exists(PATH)) {
+                    Debug::log(WARN, "source= skipping non-file {}", PATH);
+                    continue;
+                }
+    
+                Debug::log(ERR, "source= file doesnt exist");
+                return "source file " + PATH + " doesn't exist!";
+            }
+    
+            // allow for nested config parsing
+            auto backupConfigPath = configCurrentPath;
+            configCurrentPath     = PATH;
+    
+            m_config.parseFile(PATH.c_str());
+    
+            configCurrentPath = backupConfigPath;
         }
-
-        // allow for nested config parsing
-        auto backupConfigPath = configCurrentPath;
-        configCurrentPath     = PATH;
-
-        m_config.parseFile(PATH.c_str());
-
-        configCurrentPath = backupConfigPath;
+    
+        return {};
     }
-
-    return {};
-}
-
-std::optional<std::string> CConfigManager::handleBezier(const std::string& command, const std::string& args) {
-    const auto  ARGS = CVarList(args);
-
-    std::string bezierName = ARGS[0];
-
-    if (ARGS[1] == "")
-        return "too few arguments";
-    float p1x = std::stof(ARGS[1]);
-
-    if (ARGS[2] == "")
-        return "too few arguments";
-    float p1y = std::stof(ARGS[2]);
-
-    if (ARGS[3] == "")
-        return "too few arguments";
-    float p2x = std::stof(ARGS[3]);
-
-    if (ARGS[4] == "")
-        return "too few arguments";
-    float p2y = std::stof(ARGS[4]);
-
-    if (ARGS[5] != "")
-        return "too many arguments";
-
-    g_pAnimationManager->addBezierWithName(bezierName, Vector2D(p1x, p1y), Vector2D(p2x, p2y));
-
-    return {};
-}
-
-std::optional<std::string> CConfigManager::handleAnimation(const std::string& command, const std::string& args) {
-    const auto ARGS = CVarList(args);
-
-    const auto ANIMNAME = ARGS[0];
-
-    if (!m_AnimationTree.nodeExists(ANIMNAME))
-        return "no such animation";
-
-    // This helper casts strings like "1", "true", "off", "yes"... to int.
-    int64_t enabledInt = configStringToInt(ARGS[1]);
-
-    // Checking that the int is 1 or 0 because the helper can return integers out of range.
-    if (enabledInt > 1 || enabledInt < 0)
-        return "invalid animation on/off state";
-
-    if (!enabledInt) {
-        m_AnimationTree.setConfigForNode(ANIMNAME, 0, 1, "default");
+    
+    std::optional<std::string> CConfigManager::handleBezier(const std::string& command, const std::string& args) {
+        const auto  ARGS = CVarList(args);
+    
+        std::string bezierName = ARGS[0];
+    
+        if (ARGS[1] == "")
+            return "too few arguments";
+        float p1x = std::stof(ARGS[1]);
+    
+        if (ARGS[2] == "")
+            return "too few arguments";
+        float p1y = std::stof(ARGS[2]);
+    
+        if (ARGS[3] == "")
+            return "too few arguments";
+        float p2x = std::stof(ARGS[3]);
+    
+        if (ARGS[4] == "")
+            return "too few arguments";
+        float p2y = std::stof(ARGS[4]);
+    
+        if (ARGS[5] != "")
+            return "too many arguments";
+    
+        g_pAnimationManager->addBezierWithName(bezierName, Vector2D(p1x, p1y), Vector2D(p2x, p2y));
+    
         return {};
     }
-
-    int64_t speed = -1;
-
-    // speed
-    if (isNumber(ARGS[2], true)) {
-        speed = std::stof(ARGS[2]);
-
-        if (speed <= 0) {
-            speed = 1.f;
+    
+    std::optional<std::string> CConfigManager::handleAnimation(const std::string& command, const std::string& args) {
+        const auto ARGS = CVarList(args);
+    
+        const auto ANIMNAME = ARGS[0];
+    
+        if (!m_AnimationTree.nodeExists(ANIMNAME))
+            return "no such animation";
+    
+        // This helper casts strings like "1", "true", "off", "yes"... to int.
+        int64_t enabledInt = configStringToInt(ARGS[1]);
+    
+        // Checking that the int is 1 or 0 because the helper can return integers out of range.
+        if (enabledInt > 1 || enabledInt < 0)
+            return "invalid animation on/off state";
+    
+        if (!enabledInt) {
+            m_AnimationTree.setConfigForNode(ANIMNAME, 0, 1, "default");
+            return {};
+        }
+    
+        int64_t speed = -1;
+    
+        // speed
+        if (isNumber(ARGS[2], true)) {
+            speed = std::stof(ARGS[2]);
+    
+            if (speed <= 0) {
+                speed = 1.f;
+                return "invalid speed";
+            }
+        } else {
+            speed = 10.f;
             return "invalid speed";
         }
-    } else {
-        speed = 10.f;
-        return "invalid speed";
-    }
-
-    std::string bezierName = ARGS[3];
-    // ARGS[4] (style) currently usused by hyprlock
-    m_AnimationTree.setConfigForNode(ANIMNAME, enabledInt, speed, bezierName, "");
-
-    if (!g_pAnimationManager->bezierExists(bezierName)) {
-        const auto PANIMNODE      = m_AnimationTree.getConfig(ANIMNAME);
-        PANIMNODE->internalBezier = "default";
-        return "no such bezier";
-    }
-
-    return {};
-}
+    
+        std::string bezierName = ARGS[3];
+        // ARGS[4] (style) currently usused by hyprlock
+        m_AnimationTree.setConfigForNode(ANIMNAME, enabledInt, speed, bezierName, "");
+    
+        if (!g_pAnimationManager->bezierExists(bezierName)) {
+            const auto PANIMNODE      = m_AnimationTree.getConfig(ANIMNAME);
+            PANIMNODE->internalBezier = "default";
+            return "no such bezier";
+        }
+    
+        return {};
+    }
\ No newline at end of file
diff --git a/src/renderer/widgets/Background.hpp b/src/renderer/widgets/Background.hpp
index 55630020..e42b596d 100644
--- a/src/renderer/widgets/Background.hpp
+++ b/src/renderer/widgets/Background.hpp
@@ -41,6 +41,10 @@ class CBackground : public IWidget {
     void         plantReloadTimer();
     void         startCrossFadeOrUpdateRender();
 
+    // New members for video background support
+    bool         isVideoBackground = false;
+    std::string  videoPath;
+
   private:
     WP<CBackground> m_self;
 
@@ -78,4 +82,4 @@ class CBackground : public IWidget {
     CAsyncResourceGatherer::SPreloadRequest request;
     std::shared_ptr<CTimer>                 reloadTimer;
     std::filesystem::file_time_type         modificationTime;
-};
+};
\ No newline at end of file

From 4d8bf760b3f1f3d929b9aab2ffa04980699f198d Mon Sep 17 00:00:00 2001
From: RAMA <70065309+nomadxxxx@users.noreply.github.com>
Date: Thu, 10 Apr 2025 00:44:30 +1000
Subject: [PATCH 3/4] implement mpvpaper

---
 CMakeLists.txt                              |    7 +-
 protocols/wlr-layer-shell-unstable-v1.xml   |  407 +++++++
 src/config/ConfigManager.cpp                |  530 ++++-----
 src/main.cpp                                |   49 +-
 src/renderer/Renderer.cpp                   | 1182 ++++++++++---------
 src/renderer/Renderer.hpp                   |   22 +-
 src/renderer/widgets/Background.cpp         |  440 +++++--
 src/renderer/widgets/Background.hpp         |    9 +-
 src/renderer/widgets/IWidget.hpp            |    5 +-
 src/renderer/widgets/Image.cpp              |   85 +-
 src/renderer/widgets/Image.hpp              |   66 +-
 src/renderer/widgets/Label.cpp              |    7 +-
 src/renderer/widgets/Label.hpp              |   52 +-
 src/renderer/widgets/PasswordInputField.cpp |    6 +-
 src/renderer/widgets/PasswordInputField.hpp |  119 +-
 src/renderer/widgets/Shape.cpp              |  283 +++--
 src/renderer/widgets/Shape.hpp              |   51 +-
 17 files changed, 2082 insertions(+), 1238 deletions(-)
 create mode 100644 protocols/wlr-layer-shell-unstable-v1.xml

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8965b308..8bf4a979 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -28,9 +28,6 @@ set(CMAKE_CXX_STANDARD 23)
 add_compile_options(-Wall -Wextra -Wno-unused-parameter -Wno-unused-value
                     -Wno-missing-field-initializers -Wno-narrowing)
 
-
-
-
 add_compile_definitions(HYPRLOCK_VERSION="${VERSION}")
 
 if (DEFINED HYPRLOCK_COMMIT)
@@ -135,6 +132,7 @@ make_directory(${CMAKE_SOURCE_DIR}/protocols) # we don't ship any custom ones so
 
 protocolwayland()
 
+protocolnew("stable/xdg-shell" "xdg-shell" false) # Added for xdg-shell
 protocolnew("protocols" "wlr-screencopy-unstable-v1" true)
 protocolnew("staging/ext-session-lock" "ext-session-lock-v1" false)
 protocolnew("stable/linux-dmabuf" "linux-dmabuf-v1" false)
@@ -142,6 +140,7 @@ protocolnew("staging/fractional-scale" "fractional-scale-v1" false)
 protocolnew("stable/viewporter" "viewporter" false)
 protocolnew("staging/cursor-shape" "cursor-shape-v1" false)
 protocolnew("stable/tablet" "tablet-v2" false)
+protocolnew("protocols" "wlr-layer-shell-unstable-v1" true)
 
 # Installation
 install(TARGETS hyprlock)
@@ -152,4 +151,4 @@ install(FILES ${CMAKE_SOURCE_DIR}/pam/hyprlock
 install(
   FILES ${CMAKE_SOURCE_DIR}/assets/example.conf
   DESTINATION ${CMAKE_INSTALL_FULL_DATAROOTDIR}/hypr
-  RENAME hyprlock.conf)
+  RENAME hyprlock.conf)
\ No newline at end of file
diff --git a/protocols/wlr-layer-shell-unstable-v1.xml b/protocols/wlr-layer-shell-unstable-v1.xml
new file mode 100644
index 00000000..e9f27e4f
--- /dev/null
+++ b/protocols/wlr-layer-shell-unstable-v1.xml
@@ -0,0 +1,407 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wlr_layer_shell_unstable_v1">
+  <copyright>
+    Copyright © 2017 Drew DeVault
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <interface name="zwlr_layer_shell_v1" version="5">
+    <description summary="create surfaces that are layers of the desktop">
+      Clients can use this interface to assign the surface_layer role to
+      wl_surfaces. Such surfaces are assigned to a "layer" of the output and
+      rendered with a defined z-depth respective to each other. They may also be
+      anchored to the edges and corners of a screen and specify input handling
+      semantics. This interface should be suitable for the implementation of
+      many desktop shell components, and a broad number of other applications
+      that interact with the desktop.
+    </description>
+
+    <request name="get_layer_surface">
+      <description summary="create a layer_surface from a surface">
+        Create a layer surface for an existing surface. This assigns the role of
+        layer_surface, or raises a protocol error if another role is already
+        assigned.
+
+        Creating a layer surface from a wl_surface which has a buffer attached
+        or committed is a client error, and any attempts by a client to attach
+        or manipulate a buffer prior to the first layer_surface.configure call
+        must also be treated as errors.
+
+        After creating a layer_surface object and setting it up, the client
+        must perform an initial commit without any buffer attached.
+        The compositor will reply with a layer_surface.configure event.
+        The client must acknowledge it and is then allowed to attach a buffer
+        to map the surface.
+
+        You may pass NULL for output to allow the compositor to decide which
+        output to use. Generally this will be the one that the user most
+        recently interacted with.
+
+        Clients can specify a namespace that defines the purpose of the layer
+        surface.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_layer_surface_v1"/>
+      <arg name="surface" type="object" interface="wl_surface"/>
+      <arg name="output" type="object" interface="wl_output" allow-null="true"/>
+      <arg name="layer" type="uint" enum="layer" summary="layer to add this surface to"/>
+      <arg name="namespace" type="string" summary="namespace for the layer surface"/>
+    </request>
+
+    <enum name="error">
+      <entry name="role" value="0" summary="wl_surface has another role"/>
+      <entry name="invalid_layer" value="1" summary="layer value is invalid"/>
+      <entry name="already_constructed" value="2" summary="wl_surface has a buffer attached or committed"/>
+    </enum>
+
+    <enum name="layer">
+      <description summary="available layers for surfaces">
+        These values indicate which layers a surface can be rendered in. They
+        are ordered by z depth, bottom-most first. Traditional shell surfaces
+        will typically be rendered between the bottom and top layers.
+        Fullscreen shell surfaces are typically rendered at the top layer.
+        Multiple surfaces can share a single layer, and ordering within a
+        single layer is undefined.
+      </description>
+
+      <entry name="background" value="0"/>
+      <entry name="bottom" value="1"/>
+      <entry name="top" value="2"/>
+      <entry name="overlay" value="3"/>
+    </enum>
+
+    <!-- Version 3 additions -->
+
+    <request name="destroy" type="destructor" since="3">
+      <description summary="destroy the layer_shell object">
+        This request indicates that the client will not use the layer_shell
+        object any more. Objects that have been created through this instance
+        are not affected.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwlr_layer_surface_v1" version="5">
+    <description summary="layer metadata interface">
+      An interface that may be implemented by a wl_surface, for surfaces that
+      are designed to be rendered as a layer of a stacked desktop-like
+      environment.
+
+      Layer surface state (layer, size, anchor, exclusive zone,
+      margin, interactivity) is double-buffered, and will be applied at the
+      time wl_surface.commit of the corresponding wl_surface is called.
+
+      Attaching a null buffer to a layer surface unmaps it.
+
+      Unmapping a layer_surface means that the surface cannot be shown by the
+      compositor until it is explicitly mapped again. The layer_surface
+      returns to the state it had right after layer_shell.get_layer_surface.
+      The client can re-map the surface by performing a commit without any
+      buffer attached, waiting for a configure event and handling it as usual.
+    </description>
+
+    <request name="set_size">
+      <description summary="sets the size of the surface">
+        Sets the size of the surface in surface-local coordinates. The
+        compositor will display the surface centered with respect to its
+        anchors.
+
+        If you pass 0 for either value, the compositor will assign it and
+        inform you of the assignment in the configure event. You must set your
+        anchor to opposite edges in the dimensions you omit; not doing so is a
+        protocol error. Both values are 0 by default.
+
+        Size is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="width" type="uint"/>
+      <arg name="height" type="uint"/>
+    </request>
+
+    <request name="set_anchor">
+      <description summary="configures the anchor point of the surface">
+        Requests that the compositor anchor the surface to the specified edges
+        and corners. If two orthogonal edges are specified (e.g. 'top' and
+        'left'), then the anchor point will be the intersection of the edges
+        (e.g. the top left corner of the output); otherwise the anchor point
+        will be centered on that edge, or in the center if none is specified.
+
+        Anchor is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="anchor" type="uint" enum="anchor"/>
+    </request>
+
+    <request name="set_exclusive_zone">
+      <description summary="configures the exclusive geometry of this surface">
+        Requests that the compositor avoids occluding an area with other
+        surfaces. The compositor's use of this information is
+        implementation-dependent - do not assume that this region will not
+        actually be occluded.
+
+        A positive value is only meaningful if the surface is anchored to one
+        edge or an edge and both perpendicular edges. If the surface is not
+        anchored, anchored to only two perpendicular edges (a corner), anchored
+        to only two parallel edges or anchored to all edges, a positive value
+        will be treated the same as zero.
+
+        A positive zone is the distance from the edge in surface-local
+        coordinates to consider exclusive.
+
+        Surfaces that do not wish to have an exclusive zone may instead specify
+        how they should interact with surfaces that do. If set to zero, the
+        surface indicates that it would like to be moved to avoid occluding
+        surfaces with a positive exclusive zone. If set to -1, the surface
+        indicates that it would not like to be moved to accommodate for other
+        surfaces, and the compositor should extend it all the way to the edges
+        it is anchored to.
+
+        For example, a panel might set its exclusive zone to 10, so that
+        maximized shell surfaces are not shown on top of it. A notification
+        might set its exclusive zone to 0, so that it is moved to avoid
+        occluding the panel, but shell surfaces are shown underneath it. A
+        wallpaper or lock screen might set their exclusive zone to -1, so that
+        they stretch below or over the panel.
+
+        The default value is 0.
+
+        Exclusive zone is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="zone" type="int"/>
+    </request>
+
+    <request name="set_margin">
+      <description summary="sets a margin from the anchor point">
+        Requests that the surface be placed some distance away from the anchor
+        point on the output, in surface-local coordinates. Setting this value
+        for edges you are not anchored to has no effect.
+
+        The exclusive zone includes the margin.
+
+        Margin is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="top" type="int"/>
+      <arg name="right" type="int"/>
+      <arg name="bottom" type="int"/>
+      <arg name="left" type="int"/>
+    </request>
+
+    <enum name="keyboard_interactivity">
+      <description summary="types of keyboard interaction possible for a layer shell surface">
+        Types of keyboard interaction possible for layer shell surfaces. The
+        rationale for this is twofold: (1) some applications are not interested
+        in keyboard events and not allowing them to be focused can improve the
+        desktop experience; (2) some applications will want to take exclusive
+        keyboard focus.
+      </description>
+
+      <entry name="none" value="0">
+        <description summary="no keyboard focus is possible">
+          This value indicates that this surface is not interested in keyboard
+          events and the compositor should never assign it the keyboard focus.
+
+          This is the default value, set for newly created layer shell surfaces.
+
+          This is useful for e.g. desktop widgets that display information or
+          only have interaction with non-keyboard input devices.
+        </description>
+      </entry>
+      <entry name="exclusive" value="1">
+        <description summary="request exclusive keyboard focus">
+          Request exclusive keyboard focus if this surface is above the shell surface layer.
+
+          For the top and overlay layers, the seat will always give
+          exclusive keyboard focus to the top-most layer which has keyboard
+          interactivity set to exclusive. If this layer contains multiple
+          surfaces with keyboard interactivity set to exclusive, the compositor
+          determines the one receiving keyboard events in an implementation-
+          defined manner. In this case, no guarantee is made when this surface
+          will receive keyboard focus (if ever).
+
+          For the bottom and background layers, the compositor is allowed to use
+          normal focus semantics.
+
+          This setting is mainly intended for applications that need to ensure
+          they receive all keyboard events, such as a lock screen or a password
+          prompt.
+        </description>
+      </entry>
+      <entry name="on_demand" value="2" since="4">
+        <description summary="request regular keyboard focus semantics">
+          This requests the compositor to allow this surface to be focused and
+          unfocused by the user in an implementation-defined manner. The user
+          should be able to unfocus this surface even regardless of the layer
+          it is on.
+
+          Typically, the compositor will want to use its normal mechanism to
+          manage keyboard focus between layer shell surfaces with this setting
+          and regular toplevels on the desktop layer (e.g. click to focus).
+          Nevertheless, it is possible for a compositor to require a special
+          interaction to focus or unfocus layer shell surfaces (e.g. requiring
+          a click even if focus follows the mouse normally, or providing a
+          keybinding to switch focus between layers).
+
+          This setting is mainly intended for desktop shell components (e.g.
+          panels) that allow keyboard interaction. Using this option can allow
+          implementing a desktop shell that can be fully usable without the
+          mouse.
+        </description>
+      </entry>
+    </enum>
+
+    <request name="set_keyboard_interactivity">
+      <description summary="requests keyboard events">
+        Set how keyboard events are delivered to this surface. By default,
+        layer shell surfaces do not receive keyboard events; this request can
+        be used to change this.
+
+        This setting is inherited by child surfaces set by the get_popup
+        request.
+
+        Layer surfaces receive pointer, touch, and tablet events normally. If
+        you do not want to receive them, set the input region on your surface
+        to an empty region.
+
+        Keyboard interactivity is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="keyboard_interactivity" type="uint" enum="keyboard_interactivity"/>
+    </request>
+
+    <request name="get_popup">
+      <description summary="assign this layer_surface as an xdg_popup parent">
+        This assigns an xdg_popup's parent to this layer_surface.  This popup
+        should have been created via xdg_surface::get_popup with the parent set
+        to NULL, and this request must be invoked before committing the popup's
+        initial state.
+
+        See the documentation of xdg_popup for more details about what an
+        xdg_popup is and how it is used.
+      </description>
+      <arg name="popup" type="object" interface="xdg_popup"/>
+    </request>
+
+    <request name="ack_configure">
+      <description summary="ack a configure event">
+        When a configure event is received, if a client commits the
+        surface in response to the configure event, then the client
+        must make an ack_configure request sometime before the commit
+        request, passing along the serial of the configure event.
+
+        If the client receives multiple configure events before it
+        can respond to one, it only has to ack the last configure event.
+
+        A client is not required to commit immediately after sending
+        an ack_configure request - it may even ack_configure several times
+        before its next surface commit.
+
+        A client may send multiple ack_configure requests before committing, but
+        only the last request sent before a commit indicates which configure
+        event the client really is responding to.
+      </description>
+      <arg name="serial" type="uint" summary="the serial from the configure event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the layer_surface">
+        This request destroys the layer surface.
+      </description>
+    </request>
+
+    <event name="configure">
+      <description summary="suggest a surface change">
+        The configure event asks the client to resize its surface.
+
+        Clients should arrange their surface for the new states, and then send
+        an ack_configure request with the serial sent in this configure event at
+        some point before committing the new surface.
+
+        The client is free to dismiss all but the last configure event it
+        received.
+
+        The width and height arguments specify the size of the window in
+        surface-local coordinates.
+
+        The size is a hint, in the sense that the client is free to ignore it if
+        it doesn't resize, pick a smaller size (to satisfy aspect ratio or
+        resize in steps of NxM pixels). If the client picks a smaller size and
+        is anchored to two opposite anchors (e.g. 'top' and 'bottom'), the
+        surface will be centered on this axis.
+
+        If the width or height arguments are zero, it means the client should
+        decide its own window dimension.
+      </description>
+      <arg name="serial" type="uint"/>
+      <arg name="width" type="uint"/>
+      <arg name="height" type="uint"/>
+    </event>
+
+    <event name="closed">
+      <description summary="surface should be closed">
+        The closed event is sent by the compositor when the surface will no
+        longer be shown. The output may have been destroyed or the user may
+        have asked for it to be removed. Further changes to the surface will be
+        ignored. The client should destroy the resource after receiving this
+        event, and create a new surface if they so choose.
+      </description>
+    </event>
+
+    <enum name="error">
+      <entry name="invalid_surface_state" value="0" summary="provided surface state is invalid"/>
+      <entry name="invalid_size" value="1" summary="size is invalid"/>
+      <entry name="invalid_anchor" value="2" summary="anchor bitfield is invalid"/>
+      <entry name="invalid_keyboard_interactivity" value="3" summary="keyboard interactivity is invalid"/>
+      <entry name="invalid_exclusive_edge" value="4" summary="exclusive edge is invalid given the surface anchors"/>
+    </enum>
+
+    <enum name="anchor" bitfield="true">
+      <entry name="top" value="1" summary="the top edge of the anchor rectangle"/>
+      <entry name="bottom" value="2" summary="the bottom edge of the anchor rectangle"/>
+      <entry name="left" value="4" summary="the left edge of the anchor rectangle"/>
+      <entry name="right" value="8" summary="the right edge of the anchor rectangle"/>
+    </enum>
+
+    <!-- Version 2 additions -->
+
+    <request name="set_layer" since="2">
+      <description summary="change the layer of the surface">
+        Change the layer that the surface is rendered on.
+
+        Layer is double-buffered, see wl_surface.commit.
+      </description>
+      <arg name="layer" type="uint" enum="zwlr_layer_shell_v1.layer" summary="layer to move this surface to"/>
+    </request>
+
+    <!-- Version 5 additions -->
+
+    <request name="set_exclusive_edge" since="5">
+      <description summary="set the edge the exclusive zone will be applied to">
+        Requests an edge for the exclusive zone to apply. The exclusive
+        edge will be automatically deduced from anchor points when possible,
+        but when the surface is anchored to a corner, it will be necessary
+        to set it explicitly to disambiguate, as it is not possible to deduce
+        which one of the two corner edges should be used.
+
+        The edge must be one the surface is anchored to, otherwise the
+        invalid_exclusive_edge protocol error will be raised.
+      </description>
+      <arg name="edge" type="uint" enum="anchor"/>
+    </request>
+  </interface>
+</protocol>
diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 01391c4f..12e43927 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -202,7 +202,6 @@ inline static constexpr auto LAYOUTCONFIG = [](const char* default_value) -> Hyp
     return Hyprlang::CUSTOMTYPE{&configHandleLayoutOption, configHandleLayoutOptionDestroy, default_value};
 };
 void CConfigManager::init() {
-
     #define SHADOWABLE(name)                                                                                                                                                           \
         m_config.addSpecialConfigValue(name, "shadow_size", Hyprlang::INT{3});                                                                                                         \
         m_config.addSpecialConfigValue(name, "shadow_passes", Hyprlang::INT{0});                                                                                                       \
@@ -242,6 +241,7 @@ void CConfigManager::init() {
         m_config.addSpecialConfigValue("background", "reload_time", Hyprlang::INT{-1});
         m_config.addSpecialConfigValue("background", "reload_cmd", Hyprlang::STRING{""});
         m_config.addSpecialConfigValue("background", "crossfade_time", Hyprlang::FLOAT{-1.0});
+        m_config.addSpecialConfigValue("background", "fallback_path", Hyprlang::STRING{""});
     
         m_config.addSpecialCategory("shape", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
         m_config.addSpecialConfigValue("shape", "monitor", Hyprlang::STRING{""});
@@ -356,281 +356,283 @@ void CConfigManager::init() {
             Debug::log(ERR, "Config has errors:\n{}\nProceeding ignoring faulty entries", result.getError());
     
     #undef SHADOWABLE
-    }
-    std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
-        std::vector<CConfigManager::SWidgetConfig> result;
-    
+}
+
+std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
+    std::vector<CConfigManager::SWidgetConfig> result;
+
     #define SHADOWABLE(name)                                                                                                                                                           \
         {"shadow_size", m_config.getSpecialConfigValue(name, "shadow_size", k.c_str())}, {"shadow_passes", m_config.getSpecialConfigValue(name, "shadow_passes", k.c_str())},          \
             {"shadow_color", m_config.getSpecialConfigValue(name, "shadow_color", k.c_str())}, {                                                                                       \
             "shadow_boost", m_config.getSpecialConfigValue(name, "shadow_boost", k.c_str())                                                                                            \
         }
-    
-        //
-        auto keys = m_config.listKeysForSpecialCategory("background");
-        result.reserve(keys.size());
-        for (auto& k : keys) {
-            // clang-format off
-            result.push_back(CConfigManager::SWidgetConfig{
-                .type = "background",
-                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("background", "monitor", k.c_str())),
-                .values = {
-                    {"type", m_config.getSpecialConfigValue("background", "type", k.c_str())},  // New type field
-                    {"path", m_config.getSpecialConfigValue("background", "path", k.c_str())},
-                    {"color", m_config.getSpecialConfigValue("background", "color", k.c_str())},
-                    {"blur_size", m_config.getSpecialConfigValue("background", "blur_size", k.c_str())},
-                    {"blur_passes", m_config.getSpecialConfigValue("background", "blur_passes", k.c_str())},
-                    {"noise", m_config.getSpecialConfigValue("background", "noise", k.c_str())},
-                    {"contrast", m_config.getSpecialConfigValue("background", "contrast", k.c_str())},
-                    {"vibrancy", m_config.getSpecialConfigValue("background", "vibrancy", k.c_str())},
-                    {"brightness", m_config.getSpecialConfigValue("background", "brightness", k.c_str())},
-                    {"vibrancy_darkness", m_config.getSpecialConfigValue("background", "vibrancy_darkness", k.c_str())},
-                    {"zindex", m_config.getSpecialConfigValue("background", "zindex", k.c_str())},
-                    {"reload_time", m_config.getSpecialConfigValue("background", "reload_time", k.c_str())},
-                    {"reload_cmd", m_config.getSpecialConfigValue("background", "reload_cmd", k.c_str())},
-                    {"crossfade_time", m_config.getSpecialConfigValue("background", "crossfade_time", k.c_str())},
-                }
-            });
-            // clang-format on
-        }
-    
-        //
-        keys = m_config.listKeysForSpecialCategory("shape");
-        for (auto& k : keys) {
-            // clang-format off
-            result.push_back(CConfigManager::SWidgetConfig{
-                .type = "shape",
-                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("shape", "monitor", k.c_str())),
-                .values = {
-                    {"size", m_config.getSpecialConfigValue("shape", "size", k.c_str())},
-                    {"rounding", m_config.getSpecialConfigValue("shape", "rounding", k.c_str())},
-                    {"border_size", m_config.getSpecialConfigValue("shape", "border_size", k.c_str())},
-                    {"border_color", m_config.getSpecialConfigValue("shape", "border_color", k.c_str())},
-                    {"color", m_config.getSpecialConfigValue("shape", "color", k.c_str())},
-                    {"position", m_config.getSpecialConfigValue("shape", "position", k.c_str())},
-                    {"halign", m_config.getSpecialConfigValue("shape", "halign", k.c_str())},
-                    {"valign", m_config.getSpecialConfigValue("shape", "valign", k.c_str())},
-                    {"rotate", m_config.getSpecialConfigValue("shape", "rotate", k.c_str())},
-                    {"xray", m_config.getSpecialConfigValue("shape", "xray", k.c_str())},
-                    {"zindex", m_config.getSpecialConfigValue("shape", "zindex", k.c_str())},
-                    SHADOWABLE("shape"),
-                }
-            });
-            // clang-format on
-        }
-    
-        //
-        keys = m_config.listKeysForSpecialCategory("image");
-        for (auto& k : keys) {
-            // clang-format off
-            result.push_back(CConfigManager::SWidgetConfig{
-                .type = "image",
-                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("image", "monitor", k.c_str())),
-                .values = {
-                    {"path", m_config.getSpecialConfigValue("image", "path", k.c_str())},
-                    {"size", m_config.getSpecialConfigValue("image", "size", k.c_str())},
-                    {"rounding", m_config.getSpecialConfigValue("image", "rounding", k.c_str())},
-                    {"border_size", m_config.getSpecialConfigValue("image", "border_size", k.c_str())},
-                    {"border_color", m_config.getSpecialConfigValue("image", "border_color", k.c_str())},
-                    {"position", m_config.getSpecialConfigValue("image", "position", k.c_str())},
-                    {"halign", m_config.getSpecialConfigValue("image", "halign", k.c_str())},
-                    {"valign", m_config.getSpecialConfigValue("image", "valign", k.c_str())},
-                    {"rotate", m_config.getSpecialConfigValue("image", "rotate", k.c_str())},
-                    {"reload_time", m_config.getSpecialConfigValue("image", "reload_time", k.c_str())},
-                    {"reload_cmd", m_config.getSpecialConfigValue("image", "reload_cmd", k.c_str())},
-                    {"zindex", m_config.getSpecialConfigValue("image", "zindex", k.c_str())},
-                    SHADOWABLE("image"),
-                }
-            });
-            // clang-format on
-        }
-    
-        keys = m_config.listKeysForSpecialCategory("input-field");
-        for (auto& k : keys) {
-            // clang-format off
-            result.push_back(CConfigManager::SWidgetConfig{
-                .type = "input-field",
-                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("input-field", "monitor", k.c_str())),
-                .values = {
-                    {"size", m_config.getSpecialConfigValue("input-field", "size", k.c_str())},
-                    {"inner_color", m_config.getSpecialConfigValue("input-field", "inner_color", k.c_str())},
-                    {"outer_color", m_config.getSpecialConfigValue("input-field", "outer_color", k.c_str())},
-                    {"outline_thickness", m_config.getSpecialConfigValue("input-field", "outline_thickness", k.c_str())},
-                    {"dots_size", m_config.getSpecialConfigValue("input-field", "dots_size", k.c_str())},
-                    {"dots_spacing", m_config.getSpecialConfigValue("input-field", "dots_spacing", k.c_str())},
-                    {"dots_center", m_config.getSpecialConfigValue("input-field", "dots_center", k.c_str())},
-                    {"dots_rounding", m_config.getSpecialConfigValue("input-field", "dots_rounding", k.c_str())},
-                    {"dots_text_format", m_config.getSpecialConfigValue("input-field", "dots_text_format", k.c_str())},
-                    {"fade_on_empty", m_config.getSpecialConfigValue("input-field", "fade_on_empty", k.c_str())},
-                    {"fade_timeout", m_config.getSpecialConfigValue("input-field", "fade_timeout", k.c_str())},
-                    {"font_color", m_config.getSpecialConfigValue("input-field", "font_color", k.c_str())},
-                    {"font_family", m_config.getSpecialConfigValue("input-field", "font_family", k.c_str())},
-                    {"halign", m_config.getSpecialConfigValue("input-field", "halign", k.c_str())},
-                    {"valign", m_config.getSpecialConfigValue("input-field", "valign", k.c_str())},
-                    {"position", m_config.getSpecialConfigValue("input-field", "position", k.c_str())},
-                    {"placeholder_text", m_config.getSpecialConfigValue("input-field", "placeholder_text", k.c_str())},
-                    {"hide_input", m_config.getSpecialConfigValue("input-field", "hide_input", k.c_str())},
-                    {"hide_input_base_color", m_config.getSpecialConfigValue("input-field", "hide_input_base_color", k.c_str())},
-                    {"rounding", m_config.getSpecialConfigValue("input-field", "rounding", k.c_str())},
-                    {"check_color", m_config.getSpecialConfigValue("input-field", "check_color", k.c_str())},
-                    {"fail_color", m_config.getSpecialConfigValue("input-field", "fail_color", k.c_str())},
-                    {"fail_text", m_config.getSpecialConfigValue("input-field", "fail_text", k.c_str())},
-                    {"capslock_color", m_config.getSpecialConfigValue("input-field", "capslock_color", k.c_str())},
-                    {"numlock_color", m_config.getSpecialConfigValue("input-field", "numlock_color", k.c_str())},
-                    {"bothlock_color", m_config.getSpecialConfigValue("input-field", "bothlock_color", k.c_str())},
-                    {"invert_numlock", m_config.getSpecialConfigValue("input-field", "invert_numlock", k.c_str())},
-                    {"swap_font_color", m_config.getSpecialConfigValue("input-field", "swap_font_color", k.c_str())},
-                    {"zindex", m_config.getSpecialConfigValue("input-field", "zindex", k.c_str())},
-                    SHADOWABLE("input-field"),
-                }
-            });
-            // clang-format on
-        }
-        keys = m_config.listKeysForSpecialCategory("label");
-        for (auto& k : keys) {
-            // clang-format off
-            result.push_back(CConfigManager::SWidgetConfig{
-                .type = "label",
-                .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("label", "monitor", k.c_str())),
-                .values = {
-                    {"position", m_config.getSpecialConfigValue("label", "position", k.c_str())},
-                    {"color", m_config.getSpecialConfigValue("label", "color", k.c_str())},
-                    {"font_size", m_config.getSpecialConfigValue("label", "font_size", k.c_str())},
-                    {"font_family", m_config.getSpecialConfigValue("label", "font_family", k.c_str())},
-                    {"text", m_config.getSpecialConfigValue("label", "text", k.c_str())},
-                    {"halign", m_config.getSpecialConfigValue("label", "halign", k.c_str())},
-                    {"valign", m_config.getSpecialConfigValue("label", "valign", k.c_str())},
-                    {"rotate", m_config.getSpecialConfigValue("label", "rotate", k.c_str())},
-                    {"text_align", m_config.getSpecialConfigValue("label", "text_align", k.c_str())},
-                    {"zindex", m_config.getSpecialConfigValue("label", "zindex", k.c_str())},
-                    SHADOWABLE("label"),
-                }
-            });
-            // clang-format on
-        }
-    
-        return result;
+
+    //
+    auto keys = m_config.listKeysForSpecialCategory("background");
+    result.reserve(keys.size());
+    for (auto& k : keys) {
+        // clang-format off
+        result.push_back(CConfigManager::SWidgetConfig{
+            .type = "background",
+            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("background", "monitor", k.c_str())),
+            .values = {
+                {"type", m_config.getSpecialConfigValue("background", "type", k.c_str())},
+                {"path", m_config.getSpecialConfigValue("background", "path", k.c_str())},
+                {"color", m_config.getSpecialConfigValue("background", "color", k.c_str())},
+                {"blur_size", m_config.getSpecialConfigValue("background", "blur_size", k.c_str())},
+                {"blur_passes", m_config.getSpecialConfigValue("background", "blur_passes", k.c_str())},
+                {"noise", m_config.getSpecialConfigValue("background", "noise", k.c_str())},
+                {"contrast", m_config.getSpecialConfigValue("background", "contrast", k.c_str())},
+                {"vibrancy", m_config.getSpecialConfigValue("background", "vibrancy", k.c_str())},
+                {"brightness", m_config.getSpecialConfigValue("background", "brightness", k.c_str())},
+                {"vibrancy_darkness", m_config.getSpecialConfigValue("background", "vibrancy_darkness", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("background", "zindex", k.c_str())},
+                {"reload_time", m_config.getSpecialConfigValue("background", "reload_time", k.c_str())},
+                {"reload_cmd", m_config.getSpecialConfigValue("background", "reload_cmd", k.c_str())},
+                {"crossfade_time", m_config.getSpecialConfigValue("background", "crossfade_time", k.c_str())},
+                {"fallback_path", m_config.getSpecialConfigValue("background", "fallback_path", k.c_str())},
+            }
+        });
+        // clang-format on
     }
-    
-    std::optional<std::string> CConfigManager::handleSource(const std::string& command, const std::string& rawpath) {
-        if (rawpath.length() < 2) {
-            Debug::log(ERR, "source= path garbage");
-            return "source path " + rawpath + " bogus!";
-        }
-        std::unique_ptr<glob_t, void (*)(glob_t*)> glob_buf{new glob_t, [](glob_t* g) { globfree(g); }};
-        memset(glob_buf.get(), 0, sizeof(glob_t));
-    
-        const auto CURRENTDIR = std::filesystem::path(configCurrentPath).parent_path().string();
-    
-        if (auto r = glob(absolutePath(rawpath, CURRENTDIR).c_str(), GLOB_TILDE, nullptr, glob_buf.get()); r != 0) {
-            std::string err = std::format("source= globbing error: {}", r == GLOB_NOMATCH ? "found no match" : GLOB_ABORTED ? "read error" : "out of memory");
-            Debug::log(ERR, "{}", err);
-            return err;
+
+    //
+    keys = m_config.listKeysForSpecialCategory("shape");
+    for (auto& k : keys) {
+        // clang-format off
+        result.push_back(CConfigManager::SWidgetConfig{
+            .type = "shape",
+            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("shape", "monitor", k.c_str())),
+            .values = {
+                {"size", m_config.getSpecialConfigValue("shape", "size", k.c_str())},
+                {"rounding", m_config.getSpecialConfigValue("shape", "rounding", k.c_str())},
+                {"border_size", m_config.getSpecialConfigValue("shape", "border_size", k.c_str())},
+                {"border_color", m_config.getSpecialConfigValue("shape", "border_color", k.c_str())},
+                {"color", m_config.getSpecialConfigValue("shape", "color", k.c_str())},
+                {"position", m_config.getSpecialConfigValue("shape", "position", k.c_str())},
+                {"halign", m_config.getSpecialConfigValue("shape", "halign", k.c_str())},
+                {"valign", m_config.getSpecialConfigValue("shape", "valign", k.c_str())},
+                {"rotate", m_config.getSpecialConfigValue("shape", "rotate", k.c_str())},
+                {"xray", m_config.getSpecialConfigValue("shape", "xray", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("shape", "zindex", k.c_str())},
+                SHADOWABLE("shape"),
+            }
+        });
+        // clang-format on
+    }
+
+    //
+    keys = m_config.listKeysForSpecialCategory("image");
+    for (auto& k : keys) {
+        // clang-format off
+        result.push_back(CConfigManager::SWidgetConfig{
+            .type = "image",
+            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("image", "monitor", k.c_str())),
+            .values = {
+                {"path", m_config.getSpecialConfigValue("image", "path", k.c_str())},
+                {"size", m_config.getSpecialConfigValue("image", "size", k.c_str())},
+                {"rounding", m_config.getSpecialConfigValue("image", "rounding", k.c_str())},
+                {"border_size", m_config.getSpecialConfigValue("image", "border_size", k.c_str())},
+                {"border_color", m_config.getSpecialConfigValue("image", "border_color", k.c_str())},
+                {"position", m_config.getSpecialConfigValue("image", "position", k.c_str())},
+                {"halign", m_config.getSpecialConfigValue("image", "halign", k.c_str())},
+                {"valign", m_config.getSpecialConfigValue("image", "valign", k.c_str())},
+                {"rotate", m_config.getSpecialConfigValue("image", "rotate", k.c_str())},
+                {"reload_time", m_config.getSpecialConfigValue("image", "reload_time", k.c_str())},
+                {"reload_cmd", m_config.getSpecialConfigValue("image", "reload_cmd", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("image", "zindex", k.c_str())},
+                SHADOWABLE("image"),
+            }
+        });
+        // clang-format on
+    }
+
+    keys = m_config.listKeysForSpecialCategory("input-field");
+    for (auto& k : keys) {
+        // clang-format off
+        result.push_back(CConfigManager::SWidgetConfig{
+            .type = "input-field",
+            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("input-field", "monitor", k.c_str())),
+            .values = {
+                {"size", m_config.getSpecialConfigValue("input-field", "size", k.c_str())},
+                {"inner_color", m_config.getSpecialConfigValue("input-field", "inner_color", k.c_str())},
+                {"outer_color", m_config.getSpecialConfigValue("input-field", "outer_color", k.c_str())},
+                {"outline_thickness", m_config.getSpecialConfigValue("input-field", "outline_thickness", k.c_str())},
+                {"dots_size", m_config.getSpecialConfigValue("input-field", "dots_size", k.c_str())},
+                {"dots_spacing", m_config.getSpecialConfigValue("input-field", "dots_spacing", k.c_str())},
+                {"dots_center", m_config.getSpecialConfigValue("input-field", "dots_center", k.c_str())},
+                {"dots_rounding", m_config.getSpecialConfigValue("input-field", "dots_rounding", k.c_str())},
+                {"dots_text_format", m_config.getSpecialConfigValue("input-field", "dots_text_format", k.c_str())},
+                {"fade_on_empty", m_config.getSpecialConfigValue("input-field", "fade_on_empty", k.c_str())},
+                {"fade_timeout", m_config.getSpecialConfigValue("input-field", "fade_timeout", k.c_str())},
+                {"font_color", m_config.getSpecialConfigValue("input-field", "font_color", k.c_str())},
+                {"font_family", m_config.getSpecialConfigValue("input-field", "font_family", k.c_str())},
+                {"halign", m_config.getSpecialConfigValue("input-field", "halign", k.c_str())},
+                {"valign", m_config.getSpecialConfigValue("input-field", "valign", k.c_str())},
+                {"position", m_config.getSpecialConfigValue("input-field", "position", k.c_str())},
+                {"placeholder_text", m_config.getSpecialConfigValue("input-field", "placeholder_text", k.c_str())},
+                {"hide_input", m_config.getSpecialConfigValue("input-field", "hide_input", k.c_str())},
+                {"hide_input_base_color", m_config.getSpecialConfigValue("input-field", "hide_input_base_color", k.c_str())},
+                {"rounding", m_config.getSpecialConfigValue("input-field", "rounding", k.c_str())},
+                {"check_color", m_config.getSpecialConfigValue("input-field", "check_color", k.c_str())},
+                {"fail_color", m_config.getSpecialConfigValue("input-field", "fail_color", k.c_str())},
+                {"fail_text", m_config.getSpecialConfigValue("input-field", "fail_text", k.c_str())},
+                {"capslock_color", m_config.getSpecialConfigValue("input-field", "capslock_color", k.c_str())},
+                {"numlock_color", m_config.getSpecialConfigValue("input-field", "numlock_color", k.c_str())},
+                {"bothlock_color", m_config.getSpecialConfigValue("input-field", "bothlock_color", k.c_str())},
+                {"invert_numlock", m_config.getSpecialConfigValue("input-field", "invert_numlock", k.c_str())},
+                {"swap_font_color", m_config.getSpecialConfigValue("input-field", "swap_font_color", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("input-field", "zindex", k.c_str())},
+                SHADOWABLE("input-field"),
+            }
+        });
+        // clang-format on
+    }
+    keys = m_config.listKeysForSpecialCategory("label");
+    for (auto& k : keys) {
+        // clang-format off
+        result.push_back(CConfigManager::SWidgetConfig{
+            .type = "label",
+            .monitor = std::any_cast<Hyprlang::STRING>(m_config.getSpecialConfigValue("label", "monitor", k.c_str())),
+            .values = {
+                {"position", m_config.getSpecialConfigValue("label", "position", k.c_str())},
+                {"color", m_config.getSpecialConfigValue("label", "color", k.c_str())},
+                {"font_size", m_config.getSpecialConfigValue("label", "font_size", k.c_str())},
+                {"font_family", m_config.getSpecialConfigValue("label", "font_family", k.c_str())},
+                {"text", m_config.getSpecialConfigValue("label", "text", k.c_str())},
+                {"halign", m_config.getSpecialConfigValue("label", "halign", k.c_str())},
+                {"valign", m_config.getSpecialConfigValue("label", "valign", k.c_str())},
+                {"rotate", m_config.getSpecialConfigValue("label", "rotate", k.c_str())},
+                {"text_align", m_config.getSpecialConfigValue("label", "text_align", k.c_str())},
+                {"zindex", m_config.getSpecialConfigValue("label", "zindex", k.c_str())},
+                SHADOWABLE("label"),
+            }
+        });
+        // clang-format on
+    }
+
+    return result;
+}
+
+std::optional<std::string> CConfigManager::handleSource(const std::string& command, const std::string& rawpath) {
+    if (rawpath.length() < 2) {
+        Debug::log(ERR, "source= path garbage");
+        return "source path " + rawpath + " bogus!";
+    }
+    std::unique_ptr<glob_t, void (*)(glob_t*)> glob_buf{new glob_t, [](glob_t* g) { globfree(g); }};
+    memset(glob_buf.get(), 0, sizeof(glob_t));
+
+    const auto CURRENTDIR = std::filesystem::path(configCurrentPath).parent_path().string();
+
+    if (auto r = glob(absolutePath(rawpath, CURRENTDIR).c_str(), GLOB_TILDE, nullptr, glob_buf.get()); r != 0) {
+        std::string err = std::format("source= globbing error: {}", r == GLOB_NOMATCH ? "found no match" : GLOB_ABORTED ? "read error" : "out of memory");
+        Debug::log(ERR, "{}", err);
+        return err;
+    }
+
+    for (size_t i = 0; i < glob_buf->gl_pathc; i++) {
+        const auto PATH = absolutePath(glob_buf->gl_pathv[i], CURRENTDIR);
+
+        if (PATH.empty() || PATH == configCurrentPath) {
+            Debug::log(WARN, "source= skipping invalid path");
+            continue;
         }
-    
-        for (size_t i = 0; i < glob_buf->gl_pathc; i++) {
-            const auto PATH = absolutePath(glob_buf->gl_pathv[i], CURRENTDIR);
-    
-            if (PATH.empty() || PATH == configCurrentPath) {
-                Debug::log(WARN, "source= skipping invalid path");
+
+        if (!std::filesystem::is_regular_file(PATH)) {
+            if (std::filesystem::exists(PATH)) {
+                Debug::log(WARN, "source= skipping non-file {}", PATH);
                 continue;
             }
-    
-            if (!std::filesystem::is_regular_file(PATH)) {
-                if (std::filesystem::exists(PATH)) {
-                    Debug::log(WARN, "source= skipping non-file {}", PATH);
-                    continue;
-                }
-    
-                Debug::log(ERR, "source= file doesnt exist");
-                return "source file " + PATH + " doesn't exist!";
-            }
-    
-            // allow for nested config parsing
-            auto backupConfigPath = configCurrentPath;
-            configCurrentPath     = PATH;
-    
-            m_config.parseFile(PATH.c_str());
-    
-            configCurrentPath = backupConfigPath;
+
+            Debug::log(ERR, "source= file doesnt exist");
+            return "source file " + PATH + " doesn't exist!";
         }
-    
-        return {};
+
+        // allow for nested config parsing
+        auto backupConfigPath = configCurrentPath;
+        configCurrentPath     = PATH;
+
+        m_config.parseFile(PATH.c_str());
+
+        configCurrentPath = backupConfigPath;
     }
-    
-    std::optional<std::string> CConfigManager::handleBezier(const std::string& command, const std::string& args) {
-        const auto  ARGS = CVarList(args);
-    
-        std::string bezierName = ARGS[0];
-    
-        if (ARGS[1] == "")
-            return "too few arguments";
-        float p1x = std::stof(ARGS[1]);
-    
-        if (ARGS[2] == "")
-            return "too few arguments";
-        float p1y = std::stof(ARGS[2]);
-    
-        if (ARGS[3] == "")
-            return "too few arguments";
-        float p2x = std::stof(ARGS[3]);
-    
-        if (ARGS[4] == "")
-            return "too few arguments";
-        float p2y = std::stof(ARGS[4]);
-    
-        if (ARGS[5] != "")
-            return "too many arguments";
-    
-        g_pAnimationManager->addBezierWithName(bezierName, Vector2D(p1x, p1y), Vector2D(p2x, p2y));
-    
+
+    return {};
+}
+
+std::optional<std::string> CConfigManager::handleBezier(const std::string& command, const std::string& args) {
+    const auto  ARGS = CVarList(args);
+
+    std::string bezierName = ARGS[0];
+
+    if (ARGS[1] == "")
+        return "too few arguments";
+    float p1x = std::stof(ARGS[1]);
+
+    if (ARGS[2] == "")
+        return "too few arguments";
+    float p1y = std::stof(ARGS[2]);
+
+    if (ARGS[3] == "")
+        return "too few arguments";
+    float p2x = std::stof(ARGS[3]);
+
+    if (ARGS[4] == "")
+        return "too few arguments";
+    float p2y = std::stof(ARGS[4]);
+
+    if (ARGS[5] != "")
+        return "too many arguments";
+
+    g_pAnimationManager->addBezierWithName(bezierName, Vector2D(p1x, p1y), Vector2D(p2x, p2y));
+
+    return {};
+}
+
+std::optional<std::string> CConfigManager::handleAnimation(const std::string& command, const std::string& args) {
+    const auto ARGS = CVarList(args);
+
+    const auto ANIMNAME = ARGS[0];
+
+    if (!m_AnimationTree.nodeExists(ANIMNAME))
+        return "no such animation";
+
+    // This helper casts strings like "1", "true", "off", "yes"... to int.
+    int64_t enabledInt = configStringToInt(ARGS[1]);
+
+    // Checking that the int is 1 or 0 because the helper can return integers out of range.
+    if (enabledInt > 1 || enabledInt < 0)
+        return "invalid animation on/off state";
+
+    if (!enabledInt) {
+        m_AnimationTree.setConfigForNode(ANIMNAME, 0, 1, "default");
         return {};
     }
-    
-    std::optional<std::string> CConfigManager::handleAnimation(const std::string& command, const std::string& args) {
-        const auto ARGS = CVarList(args);
-    
-        const auto ANIMNAME = ARGS[0];
-    
-        if (!m_AnimationTree.nodeExists(ANIMNAME))
-            return "no such animation";
-    
-        // This helper casts strings like "1", "true", "off", "yes"... to int.
-        int64_t enabledInt = configStringToInt(ARGS[1]);
-    
-        // Checking that the int is 1 or 0 because the helper can return integers out of range.
-        if (enabledInt > 1 || enabledInt < 0)
-            return "invalid animation on/off state";
-    
-        if (!enabledInt) {
-            m_AnimationTree.setConfigForNode(ANIMNAME, 0, 1, "default");
-            return {};
-        }
-    
-        int64_t speed = -1;
-    
-        // speed
-        if (isNumber(ARGS[2], true)) {
-            speed = std::stof(ARGS[2]);
-    
-            if (speed <= 0) {
-                speed = 1.f;
-                return "invalid speed";
-            }
-        } else {
-            speed = 10.f;
+
+    int64_t speed = -1;
+
+    // speed
+    if (isNumber(ARGS[2], true)) {
+        speed = std::stof(ARGS[2]);
+
+        if (speed <= 0) {
+            speed = 1.f;
             return "invalid speed";
         }
-    
-        std::string bezierName = ARGS[3];
-        // ARGS[4] (style) currently usused by hyprlock
-        m_AnimationTree.setConfigForNode(ANIMNAME, enabledInt, speed, bezierName, "");
-    
-        if (!g_pAnimationManager->bezierExists(bezierName)) {
-            const auto PANIMNODE      = m_AnimationTree.getConfig(ANIMNAME);
-            PANIMNODE->internalBezier = "default";
-            return "no such bezier";
-        }
-    
-        return {};
-    }
\ No newline at end of file
+    } else {
+        speed = 10.f;
+        return "invalid speed";
+    }
+
+    std::string bezierName = ARGS[3];
+    // ARGS[4] (style) currently usused by hyprlock
+    m_AnimationTree.setConfigForNode(ANIMNAME, enabledInt, speed, bezierName, "");
+
+    if (!g_pAnimationManager->bezierExists(bezierName)) {
+        const auto PANIMNODE      = m_AnimationTree.getConfig(ANIMNAME);
+        PANIMNODE->internalBezier = "default";
+        return "no such bezier";
+    }
+
+    return {};
+}
\ No newline at end of file
diff --git a/src/main.cpp b/src/main.cpp
index 3ab2d91a..0347c55b 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -1,4 +1,3 @@
-
 #include "config/ConfigManager.hpp"
 #include "core/hyprlock.hpp"
 #include "helpers/Log.hpp"
@@ -93,30 +92,38 @@ int main(int argc, char** argv, char** envp) {
         }
     }
 
-    printVersion();
-    g_pAnimationManager = makeUnique<CHyprlockAnimationManager>();
-
     try {
-        g_pConfigManager = makeUnique<CConfigManager>(configPath);
-        g_pConfigManager->init();
-    } catch (const std::exception& ex) {
-        Debug::log(CRIT, "ConfigManager threw: {}", ex.what());
-        if (std::string(ex.what()).contains("File does not exist"))
-            Debug::log(NONE, "           Make sure you have a config.");
-
-        return 1;
-    }
+        printVersion();
+        g_pAnimationManager = makeUnique<CHyprlockAnimationManager>();
+
+        try {
+            g_pConfigManager = makeUnique<CConfigManager>(configPath);
+            g_pConfigManager->init();
+        } catch (const std::exception& ex) {
+            Debug::log(CRIT, "ConfigManager threw: {}", ex.what());
+            if (std::string(ex.what()).contains("File does not exist"))
+                Debug::log(NONE, "           Make sure you have a config.");
+
+            throw; // Re-throw to outer catch
+        }
 
-    if (noFadeIn)
-        g_pConfigManager->m_AnimationTree.setConfigForNode("fadeIn", false, 0.f, "default");
+        if (noFadeIn)
+            g_pConfigManager->m_AnimationTree.setConfigForNode("fadeIn", false, 0.f, "default");
 
-    try {
-        g_pHyprlock = makeUnique<CHyprlock>(wlDisplay, immediate, immediateRender);
-        g_pHyprlock->run();
-    } catch (const std::exception& ex) {
-        Debug::log(CRIT, "Hyprlock threw: {}", ex.what());
+        try {
+            g_pHyprlock = makeUnique<CHyprlock>(wlDisplay, immediate, immediateRender);
+            g_pHyprlock->run();
+        } catch (const std::exception& ex) {
+            Debug::log(CRIT, "Hyprlock threw: {}", ex.what());
+            throw; // Re-throw to outer catch
+        }
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "Unhandled exception in main: {}", e.what());
+        return 1;
+    } catch (...) {
+        Debug::log(ERR, "Unknown exception in main");
         return 1;
     }
 
     return 0;
-}
+}
\ No newline at end of file
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 6be90f6e..98b69edd 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -8,17 +8,21 @@
 #include "../core/hyprlock.hpp"
 #include "../helpers/Color.hpp"
 #include "../helpers/Log.hpp"
-#include <GLES3/gl32.h>
-#include <GLES3/gl3ext.h>
-#include <GLES2/gl2ext.h>
-#include <algorithm>
 #include "widgets/PasswordInputField.hpp"
 #include "widgets/Background.hpp"
 #include "widgets/Label.hpp"
 #include "widgets/Image.hpp"
 #include "widgets/Shape.hpp"
-#include <cstdlib>  // For system()
-#include <string>
+#include <GLES3/gl32.h>
+#include <GLES3/gl3ext.h>
+#include <GLES2/gl2ext.h>
+#include <algorithm>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <signal.h>
+#include <stdexcept>
+#include <mutex> // Added for mpvpaper safeguards
 
 inline const float fullVerts[] = {
     1, 0, // top right
@@ -28,46 +32,62 @@ inline const float fullVerts[] = {
 };
 
 GLuint compileShader(const GLuint& type, std::string src) {
-    auto shader = glCreateShader(type);
-
-    auto shaderSource = src.c_str();
-
-    glShaderSource(shader, 1, &shaderSource, nullptr);
-    glCompileShader(shader);
-
-    GLint ok;
-    glGetShaderiv(shader, GL_COMPILE_STATUS, &ok);
-
-    RASSERT(ok != GL_FALSE, "compileShader() failed! GL_COMPILE_STATUS not OK!");
-
-    return shader;
+    try {
+        auto shader = glCreateShader(type);
+        auto shaderSource = src.c_str();
+        glShaderSource(shader, 1, &shaderSource, nullptr);
+        glCompileShader(shader);
+
+        GLint ok;
+        glGetShaderiv(shader, GL_COMPILE_STATUS, &ok);
+        if (ok == GL_FALSE) {
+            char infoLog[512];
+            glGetShaderInfoLog(shader, 512, nullptr, infoLog);
+            Debug::log(ERR, "compileShader failed: {}", infoLog);
+            glDeleteShader(shader);
+            throw std::runtime_error("Shader compilation failed");
+        }
+        return shader;
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "compileShader threw: {}", e.what());
+        throw;
+    }
 }
 
 GLuint createProgram(const std::string& vert, const std::string& frag) {
-    auto vertCompiled = compileShader(GL_VERTEX_SHADER, vert);
-
-    RASSERT(vertCompiled, "Compiling shader failed. VERTEX NULL! Shader source:\n\n{}", vert);
-
-    auto fragCompiled = compileShader(GL_FRAGMENT_SHADER, frag);
-
-    RASSERT(fragCompiled, "Compiling shader failed. FRAGMENT NULL! Shader source:\n\n{}", frag);
-
-    auto prog = glCreateProgram();
-    glAttachShader(prog, vertCompiled);
-    glAttachShader(prog, fragCompiled);
-    glLinkProgram(prog);
-
-    glDetachShader(prog, vertCompiled);
-    glDetachShader(prog, fragCompiled);
-    glDeleteShader(vertCompiled);
-    glDeleteShader(fragCompiled);
-
-    GLint ok;
-    glGetProgramiv(prog, GL_LINK_STATUS, &ok);
-
-    RASSERT(ok != GL_FALSE, "createProgram() failed! GL_LINK_STATUS not OK!");
-
-    return prog;
+    try {
+        auto vertCompiled = compileShader(GL_VERTEX_SHADER, vert);
+        if (!vertCompiled)
+            throw std::runtime_error("Vertex shader compilation returned NULL");
+
+        auto fragCompiled = compileShader(GL_FRAGMENT_SHADER, frag);
+        if (!fragCompiled)
+            throw std::runtime_error("Fragment shader compilation returned NULL");
+
+        auto prog = glCreateProgram();
+        glAttachShader(prog, vertCompiled);
+        glAttachShader(prog, fragCompiled);
+        glLinkProgram(prog);
+
+        glDetachShader(prog, vertCompiled);
+        glDetachShader(prog, fragCompiled);
+        glDeleteShader(vertCompiled);
+        glDeleteShader(fragCompiled);
+
+        GLint ok;
+        glGetProgramiv(prog, GL_LINK_STATUS, &ok);
+        if (ok == GL_FALSE) {
+            char infoLog[512];
+            glGetProgramInfoLog(prog, 512, nullptr, infoLog);
+            Debug::log(ERR, "createProgram failed: {}", infoLog);
+            glDeleteProgram(prog);
+            throw std::runtime_error("Program linking failed");
+        }
+        return prog;
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "createProgram threw: {}", e.what());
+        throw;
+    }
 }
 
 static void glMessageCallbackA(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam) {
@@ -77,367 +97,362 @@ static void glMessageCallbackA(GLenum source, GLenum type, GLuint id, GLenum sev
 }
 
 CRenderer::CRenderer() {
-    g_pEGL->makeCurrent(nullptr);
-
-    glEnable(GL_DEBUG_OUTPUT);
-    glDebugMessageCallback(glMessageCallbackA, nullptr);
-
-    GLuint prog          = createProgram(QUADVERTSRC, QUADFRAGSRC);
-    rectShader.program   = prog;
-    rectShader.proj      = glGetUniformLocation(prog, "proj");
-    rectShader.color     = glGetUniformLocation(prog, "color");
-    rectShader.posAttrib = glGetAttribLocation(prog, "pos");
-    rectShader.topLeft   = glGetUniformLocation(prog, "topLeft");
-    rectShader.fullSize  = glGetUniformLocation(prog, "fullSize");
-    rectShader.radius    = glGetUniformLocation(prog, "radius");
-
-    prog                        = createProgram(TEXVERTSRC, TEXFRAGSRCRGBA);
-    texShader.program           = prog;
-    texShader.proj              = glGetUniformLocation(prog, "proj");
-    texShader.tex               = glGetUniformLocation(prog, "tex");
-    texShader.alphaMatte        = glGetUniformLocation(prog, "texMatte");
-    texShader.alpha             = glGetUniformLocation(prog, "alpha");
-    texShader.texAttrib         = glGetAttribLocation(prog, "texcoord");
-    texShader.matteTexAttrib    = glGetAttribLocation(prog, "texcoordMatte");
-    texShader.posAttrib         = glGetAttribLocation(prog, "pos");
-    texShader.discardOpaque     = glGetUniformLocation(prog, "discardOpaque");
-    texShader.discardAlpha      = glGetUniformLocation(prog, "discardAlpha");
-    texShader.discardAlphaValue = glGetUniformLocation(prog, "discardAlphaValue");
-    texShader.topLeft           = glGetUniformLocation(prog, "topLeft");
-    texShader.fullSize          = glGetUniformLocation(prog, "fullSize");
-    texShader.radius            = glGetUniformLocation(prog, "radius");
-    texShader.applyTint         = glGetUniformLocation(prog, "applyTint");
-    texShader.tint              = glGetUniformLocation(prog, "tint");
-    texShader.useAlphaMatte     = glGetUniformLocation(prog, "useAlphaMatte");
-
-    prog                           = createProgram(TEXVERTSRC, TEXMIXFRAGSRCRGBA);
-    texMixShader.program           = prog;
-    texMixShader.proj              = glGetUniformLocation(prog, "proj");
-    texMixShader.tex               = glGetUniformLocation(prog, "tex1");
-    texMixShader.tex2              = glGetUniformLocation(prog, "tex2");
-    texMixShader.alphaMatte        = glGetUniformLocation(prog, "texMatte");
-    texMixShader.alpha             = glGetUniformLocation(prog, "alpha");
-    texMixShader.mixFactor         = glGetUniformLocation(prog, "mixFactor");
-    texMixShader.texAttrib         = glGetAttribLocation(prog, "texcoord");
-    texMixShader.matteTexAttrib    = glGetAttribLocation(prog, "texcoordMatte");
-    texMixShader.posAttrib         = glGetAttribLocation(prog, "pos");
-    texMixShader.discardOpaque     = glGetUniformLocation(prog, "discardOpaque");
-    texMixShader.discardAlpha      = glGetUniformLocation(prog, "discardAlpha");
-    texMixShader.discardAlphaValue = glGetUniformLocation(prog, "discardAlphaValue");
-    texMixShader.topLeft           = glGetUniformLocation(prog, "topLeft");
-    texMixShader.fullSize          = glGetUniformLocation(prog, "fullSize");
-    texMixShader.radius            = glGetUniformLocation(prog, "radius");
-    texMixShader.applyTint         = glGetUniformLocation(prog, "applyTint");
-    texMixShader.tint              = glGetUniformLocation(prog, "tint");
-    texMixShader.useAlphaMatte     = glGetUniformLocation(prog, "useAlphaMatte");
-
-    prog                          = createProgram(TEXVERTSRC, FRAGBLUR1);
-    blurShader1.program           = prog;
-    blurShader1.tex               = glGetUniformLocation(prog, "tex");
-    blurShader1.alpha             = glGetUniformLocation(prog, "alpha");
-    blurShader1.proj              = glGetUniformLocation(prog, "proj");
-    blurShader1.posAttrib         = glGetAttribLocation(prog, "pos");
-    blurShader1.texAttrib         = glGetAttribLocation(prog, "texcoord");
-    blurShader1.radius            = glGetUniformLocation(prog, "radius");
-    blurShader1.halfpixel         = glGetUniformLocation(prog, "halfpixel");
-    blurShader1.passes            = glGetUniformLocation(prog, "passes");
-    blurShader1.vibrancy          = glGetUniformLocation(prog, "vibrancy");
-    blurShader1.vibrancy_darkness = glGetUniformLocation(prog, "vibrancy_darkness");
-
-    prog                  = createProgram(TEXVERTSRC, FRAGBLUR2);
-    blurShader2.program   = prog;
-    blurShader2.tex       = glGetUniformLocation(prog, "tex");
-    blurShader2.alpha     = glGetUniformLocation(prog, "alpha");
-    blurShader2.proj      = glGetUniformLocation(prog, "proj");
-    blurShader2.posAttrib = glGetAttribLocation(prog, "pos");
-    blurShader2.texAttrib = glGetAttribLocation(prog, "texcoord");
-    blurShader2.radius    = glGetUniformLocation(prog, "radius");
-    blurShader2.halfpixel = glGetUniformLocation(prog, "halfpixel");
-
-    prog                         = createProgram(TEXVERTSRC, FRAGBLURPREPARE);
-    blurPrepareShader.program    = prog;
-    blurPrepareShader.tex        = glGetUniformLocation(prog, "tex");
-    blurPrepareShader.proj       = glGetUniformLocation(prog, "proj");
-    blurPrepareShader.posAttrib  = glGetAttribLocation(prog, "pos");
-    blurPrepareShader.texAttrib  = glGetAttribLocation(prog, "texcoord");
-    blurPrepareShader.contrast   = glGetUniformLocation(prog, "contrast");
-    blurPrepareShader.brightness = glGetUniformLocation(prog, "brightness");
-
-    prog                          = createProgram(TEXVERTSRC, FRAGBLURFINISH);
-    blurFinishShader.program      = prog;
-    blurFinishShader.tex          = glGetUniformLocation(prog, "tex");
-    blurFinishShader.proj         = glGetUniformLocation(prog, "proj");
-    blurFinishShader.posAttrib    = glGetAttribLocation(prog, "pos");
-    blurFinishShader.texAttrib    = glGetAttribLocation(prog, "texcoord");
-    blurFinishShader.brightness   = glGetUniformLocation(prog, "brightness");
-    blurFinishShader.noise        = glGetUniformLocation(prog, "noise");
-    blurFinishShader.colorize     = glGetUniformLocation(prog, "colorize");
-    blurFinishShader.colorizeTint = glGetUniformLocation(prog, "colorizeTint");
-    blurFinishShader.boostA       = glGetUniformLocation(prog, "boostA");
-
-    prog                               = createProgram(QUADVERTSRC, FRAGBORDER);
-    borderShader.program               = prog;
-    borderShader.proj                  = glGetUniformLocation(prog, "proj");
-    borderShader.thick                 = glGetUniformLocation(prog, "thick");
-    borderShader.posAttrib             = glGetAttribLocation(prog, "pos");
-    borderShader.texAttrib             = glGetAttribLocation(prog, "texcoord");
-    borderShader.topLeft               = glGetUniformLocation(prog, "topLeft");
-    borderShader.bottomRight           = glGetUniformLocation(prog, "bottomRight");
-    borderShader.fullSize              = glGetUniformLocation(prog, "fullSize");
-    borderShader.fullSizeUntransformed = glGetUniformLocation(prog, "fullSizeUntransformed");
-    borderShader.radius                = glGetUniformLocation(prog, "radius");
-    borderShader.radiusOuter           = glGetUniformLocation(prog, "radiusOuter");
-    borderShader.gradient              = glGetUniformLocation(prog, "gradient");
-    borderShader.gradientLength        = glGetUniformLocation(prog, "gradientLength");
-    borderShader.angle                 = glGetUniformLocation(prog, "angle");
-    borderShader.gradient2             = glGetUniformLocation(prog, "gradient2");
-    borderShader.gradient2Length       = glGetUniformLocation(prog, "gradient2Length");
-    borderShader.angle2                = glGetUniformLocation(prog, "angle2");
-    borderShader.gradientLerp          = glGetUniformLocation(prog, "gradientLerp");
-    borderShader.alpha                 = glGetUniformLocation(prog, "alpha");
-
-    asyncResourceGatherer = makeUnique<CAsyncResourceGatherer>();
-
-    g_pAnimationManager->createAnimation(0.f, opacity, g_pConfigManager->m_AnimationTree.getConfig("fadeIn"));
-
-    mpvpaperRunning = false;  // Initialize the flag
-}
-
-CRenderer::~CRenderer() {
-    stopMpvpaper();  // Ensure mpvpaper is stopped when the renderer is destroyed
-}
-
-void CRenderer::startMpvpaper(const std::string& monitor, const std::string& videoPath) {
-    if (mpvpaperRunning) {
-        stopMpvpaper();  // Ensure no existing mpvpaper instance is running
+    try {
+        g_pEGL->makeCurrent(nullptr);
+        glEnable(GL_DEBUG_OUTPUT);
+        glDebugMessageCallback(glMessageCallbackA, nullptr);
+
+        GLuint prog = createProgram(QUADVERTSRC, QUADFRAGSRC);
+        rectShader.program = prog;
+        rectShader.proj = glGetUniformLocation(prog, "proj");
+        rectShader.color = glGetUniformLocation(prog, "color");
+        rectShader.posAttrib = glGetAttribLocation(prog, "pos");
+        rectShader.topLeft = glGetUniformLocation(prog, "topLeft");
+        rectShader.fullSize = glGetUniformLocation(prog, "fullSize");
+        rectShader.radius = glGetUniformLocation(prog, "radius");
+
+        prog = createProgram(TEXVERTSRC, TEXFRAGSRCRGBA);
+        texShader.program = prog;
+        texShader.proj = glGetUniformLocation(prog, "proj");
+        texShader.tex = glGetUniformLocation(prog, "tex");
+        texShader.alphaMatte = glGetUniformLocation(prog, "texMatte");
+        texShader.alpha = glGetUniformLocation(prog, "alpha");
+        texShader.texAttrib = glGetAttribLocation(prog, "texcoord");
+        texShader.matteTexAttrib = glGetAttribLocation(prog, "texcoordMatte");
+        texShader.posAttrib = glGetAttribLocation(prog, "pos");
+        texShader.discardOpaque = glGetUniformLocation(prog, "discardOpaque");
+        texShader.discardAlpha = glGetUniformLocation(prog, "discardAlpha");
+        texShader.discardAlphaValue = glGetUniformLocation(prog, "discardAlphaValue");
+        texShader.topLeft = glGetUniformLocation(prog, "topLeft");
+        texShader.fullSize = glGetUniformLocation(prog, "fullSize");
+        texShader.radius = glGetUniformLocation(prog, "radius");
+        texShader.applyTint = glGetUniformLocation(prog, "applyTint");
+        texShader.tint = glGetUniformLocation(prog, "tint");
+        texShader.useAlphaMatte = glGetUniformLocation(prog, "useAlphaMatte");
+
+        prog = createProgram(TEXVERTSRC, TEXMIXFRAGSRCRGBA);
+        texMixShader.program = prog;
+        texMixShader.proj = glGetUniformLocation(prog, "proj");
+        texMixShader.tex = glGetUniformLocation(prog, "tex1");
+        texMixShader.tex2 = glGetUniformLocation(prog, "tex2");
+        texMixShader.alphaMatte = glGetUniformLocation(prog, "texMatte");
+        texMixShader.alpha = glGetUniformLocation(prog, "alpha");
+        texMixShader.mixFactor = glGetUniformLocation(prog, "mixFactor");
+        texMixShader.texAttrib = glGetAttribLocation(prog, "texcoord");
+        texMixShader.matteTexAttrib = glGetAttribLocation(prog, "texcoordMatte");
+        texMixShader.posAttrib = glGetAttribLocation(prog, "pos");
+        texMixShader.discardOpaque = glGetUniformLocation(prog, "discardOpaque");
+        texMixShader.discardAlpha = glGetUniformLocation(prog, "discardAlpha");
+        texMixShader.discardAlphaValue = glGetUniformLocation(prog, "discardAlphaValue");
+        texMixShader.topLeft = glGetUniformLocation(prog, "topLeft");
+        texMixShader.fullSize = glGetUniformLocation(prog, "fullSize");
+        texMixShader.radius = glGetUniformLocation(prog, "radius");
+        texMixShader.applyTint = glGetUniformLocation(prog, "applyTint");
+        texMixShader.tint = glGetUniformLocation(prog, "tint");
+        texMixShader.useAlphaMatte = glGetUniformLocation(prog, "useAlphaMatte");
+
+        prog = createProgram(TEXVERTSRC, FRAGBLUR1);
+        blurShader1.program = prog;
+        blurShader1.tex = glGetUniformLocation(prog, "tex");
+        blurShader1.alpha = glGetUniformLocation(prog, "alpha");
+        blurShader1.proj = glGetUniformLocation(prog, "proj");
+        blurShader1.posAttrib = glGetAttribLocation(prog, "pos");
+        blurShader1.texAttrib = glGetAttribLocation(prog, "texcoord");
+        blurShader1.radius = glGetUniformLocation(prog, "radius");
+        blurShader1.halfpixel = glGetUniformLocation(prog, "halfpixel");
+        blurShader1.passes = glGetUniformLocation(prog, "passes");
+        blurShader1.vibrancy = glGetUniformLocation(prog, "vibrancy");
+        blurShader1.vibrancy_darkness = glGetUniformLocation(prog, "vibrancy_darkness");
+
+        prog = createProgram(TEXVERTSRC, FRAGBLUR2);
+        blurShader2.program = prog;
+        blurShader2.tex = glGetUniformLocation(prog, "tex");
+        blurShader2.alpha = glGetUniformLocation(prog, "alpha");
+        blurShader2.proj = glGetUniformLocation(prog, "proj");
+        blurShader2.posAttrib = glGetAttribLocation(prog, "pos");
+        blurShader2.texAttrib = glGetAttribLocation(prog, "texcoord");
+        blurShader2.radius = glGetUniformLocation(prog, "radius");
+        blurShader2.halfpixel = glGetUniformLocation(prog, "halfpixel");
+
+        prog = createProgram(TEXVERTSRC, FRAGBLURPREPARE);
+        blurPrepareShader.program = prog;
+        blurPrepareShader.tex = glGetUniformLocation(prog, "tex");
+        blurPrepareShader.proj = glGetUniformLocation(prog, "proj");
+        blurPrepareShader.posAttrib = glGetAttribLocation(prog, "pos");
+        blurPrepareShader.texAttrib = glGetAttribLocation(prog, "texcoord");
+        blurPrepareShader.contrast = glGetUniformLocation(prog, "contrast");
+        blurPrepareShader.brightness = glGetUniformLocation(prog, "brightness");
+
+        prog = createProgram(TEXVERTSRC, FRAGBLURFINISH);
+        blurFinishShader.program = prog;
+        blurFinishShader.tex = glGetUniformLocation(prog, "tex");
+        blurFinishShader.proj = glGetUniformLocation(prog, "proj");
+        blurFinishShader.posAttrib = glGetAttribLocation(prog, "pos");
+        blurFinishShader.texAttrib = glGetAttribLocation(prog, "texcoord");
+        blurFinishShader.brightness = glGetUniformLocation(prog, "brightness");
+        blurFinishShader.noise = glGetUniformLocation(prog, "noise");
+        blurFinishShader.colorize = glGetUniformLocation(prog, "colorize");
+        blurFinishShader.colorizeTint = glGetUniformLocation(prog, "colorizeTint");
+        blurFinishShader.boostA = glGetUniformLocation(prog, "boostA");
+
+        prog = createProgram(QUADVERTSRC, FRAGBORDER);
+        borderShader.program = prog;
+        borderShader.proj = glGetUniformLocation(prog, "proj");
+        borderShader.thick = glGetUniformLocation(prog, "thick");
+        borderShader.posAttrib = glGetAttribLocation(prog, "pos");
+        borderShader.texAttrib = glGetAttribLocation(prog, "texcoord");
+        borderShader.topLeft = glGetUniformLocation(prog, "topLeft");
+        borderShader.bottomRight = glGetUniformLocation(prog, "bottomRight");
+        borderShader.fullSize = glGetUniformLocation(prog, "fullSize");
+        borderShader.fullSizeUntransformed = glGetUniformLocation(prog, "fullSizeUntransformed");
+        borderShader.radius = glGetUniformLocation(prog, "radius");
+        borderShader.radiusOuter = glGetUniformLocation(prog, "radiusOuter");
+        borderShader.gradient = glGetUniformLocation(prog, "gradient");
+        borderShader.gradientLength = glGetUniformLocation(prog, "gradientLength");
+        borderShader.angle = glGetUniformLocation(prog, "angle");
+        borderShader.gradient2 = glGetUniformLocation(prog, "gradient2");
+        borderShader.gradient2Length = glGetUniformLocation(prog, "gradient2Length");
+        borderShader.angle2 = glGetUniformLocation(prog, "angle2");
+        borderShader.gradientLerp = glGetUniformLocation(prog, "gradientLerp");
+        borderShader.alpha = glGetUniformLocation(prog, "alpha");
+
+        asyncResourceGatherer = makeUnique<CAsyncResourceGatherer>();
+        g_pAnimationManager->createAnimation(0.f, opacity, g_pConfigManager->m_AnimationTree.getConfig("fadeIn"));
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "CRenderer constructor failed: {}", e.what());
+        throw;
     }
-
-    // Construct the mpvpaper command
-    std::string mpvpaperCmd = "mpvpaper -o \"--loop=inf --no-osc --no-osd-bar\" " + monitor + " " + videoPath + " &";
-    system(mpvpaperCmd.c_str());
-    mpvpaperRunning = true;
-    currentMonitor = monitor;
-    currentVideoPath = videoPath;
-
-    Debug::log(LOG, "Started mpvpaper on monitor {} with video {}", monitor, videoPath);
 }
 
-void CRenderer::stopMpvpaper() {
-    if (mpvpaperRunning) {
-        system("pkill mpvpaper");
-        mpvpaperRunning = false;
-        currentMonitor = "";
-        currentVideoPath = "";
-        Debug::log(LOG, "Stopped mpvpaper");
+void CRenderer::renderBackground(const CSessionLockSurface& surf, float opacity) {
+    try {
+        auto widgets = getOrCreateWidgetsFor(surf);
+        for (auto& w : widgets) {
+            if (w->type() == "background") {
+                w->draw({opacity});
+            }
+        }
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "renderBackground failed for output {}: {}", surf.m_outputRef.lock()->stringPort, e.what());
     }
 }
 
-//
-CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf) {
-    projection = Mat3x3::outputProjection(surf.size, HYPRUTILS_TRANSFORM_NORMAL);
-
-    g_pEGL->makeCurrent(surf.eglSurface);
-    glViewport(0, 0, surf.size.x, surf.size.y);
-
-    GLint fb = 0;
-    glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &fb);
-    pushFb(fb);
-
-    glClearColor(0.0, 0.0, 0.0, 0.0);  // Clear to transparent
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
-
-    SRenderFeedback feedback;
-    const bool      WAITFORASSETS = !g_pHyprlock->m_bImmediateRender && !asyncResourceGatherer->gathered;
-
-    if (!WAITFORASSETS) {
-        // Render widgets
-        const auto WIDGETS = getOrCreateWidgetsFor(surf);
-        bool hasVideoBackground = false;
-
-        // Check for a video background
-        for (auto& w : WIDGETS) {
-            if (auto* bg = dynamic_cast<CBackground*>(w.get()); bg) {
-                if (bg->isVideoBackground) {
-                    hasVideoBackground = true;
-                    // Launch mpvpaper if not already running
-                    if (!mpvpaperRunning) {
-                        std::string monitor = surf.m_outputRef.lock()->stringPort;  // Get monitor output name
-                        startMpvpaper(monitor, bg->videoPath);
-                    }
-                    // Skip rendering the background widget since mpvpaper is handling it
-                    continue;
-                }
+void CRenderer::renderShapes(const CSessionLockSurface& surf, float opacity) {
+    try {
+        auto widgets = getOrCreateWidgetsFor(surf);
+        for (auto& w : widgets) {
+            if (w->type() == "shape") {
+                w->draw({opacity});
             }
-            feedback.needsFrame = w->draw({opacity->value()}) || feedback.needsFrame;
         }
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "renderShapes failed for output {}: {}", surf.m_outputRef.lock()->stringPort, e.what());
+    }
+}
 
-        // If we have a video background, ensure the background is transparent
-        if (hasVideoBackground) {
-            glClearColor(0.0, 0.0, 0.0, 0.0);  // Ensure transparency
+void CRenderer::renderInputFields(const CSessionLockSurface& surf, float opacity) {
+    try {
+        auto widgets = getOrCreateWidgetsFor(surf);
+        for (auto& w : widgets) {
+            if (w->type() == "input-field") {
+                w->draw({opacity});
+            }
         }
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "renderInputFields failed for output {}: {}", surf.m_outputRef.lock()->stringPort, e.what());
     }
-
-    feedback.needsFrame = feedback.needsFrame || !asyncResourceGatherer->gathered;
-
-    glDisable(GL_BLEND);
-
-    return feedback;
 }
-void CRenderer::renderRect(const CBox& box, const CHyprColor& col, int rounding) {
-    const auto ROUNDEDBOX = box.copy().round();
-    Mat3x3     matrix     = projMatrix.projectBox(ROUNDEDBOX, HYPRUTILS_TRANSFORM_NORMAL, box.rot);
-    Mat3x3     glMatrix   = projection.copy().multiply(matrix);
 
-    glUseProgram(rectShader.program);
+CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf) {
+    try {
+        projection = Mat3x3::outputProjection(surf.size, HYPRUTILS_TRANSFORM_NORMAL);
+        g_pEGL->makeCurrent(surf.eglSurface);
+        glViewport(0, 0, surf.size.x, surf.size.y);
 
-    glUniformMatrix3fv(rectShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
+        GLint fb = 0;
+        glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &fb);
+        pushFb(fb);
 
-    // premultiply the color as well as we don't work with straight alpha
-    glUniform4f(rectShader.color, col.r * col.a, col.g * col.a, col.b * col.a, col.a);
+        glClearColor(0.0, 0.0, 0.0, 0.0);
+        glClear(GL_COLOR_BUFFER_BIT);
 
-    const auto TOPLEFT  = Vector2D(ROUNDEDBOX.x, ROUNDEDBOX.y);
-    const auto FULLSIZE = Vector2D(ROUNDEDBOX.width, ROUNDEDBOX.height);
+        glEnable(GL_BLEND);
+        glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
 
-    // Rounded corners
-    glUniform2f(rectShader.topLeft, (float)TOPLEFT.x, (float)TOPLEFT.y);
-    glUniform2f(rectShader.fullSize, (float)FULLSIZE.x, (float)FULLSIZE.y);
-    glUniform1f(rectShader.radius, rounding);
+        SRenderFeedback feedback;
+        const bool WAITFORASSETS = !g_pHyprlock->m_bImmediateRender && !asyncResourceGatherer->gathered;
 
-    glVertexAttribPointer(rectShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+        if (!WAITFORASSETS) {
+            // Render in explicit order: background, shapes, input fields
+            renderBackground(surf, opacity->value());
+            renderShapes(surf, opacity->value());
+            renderInputFields(surf, opacity->value());
 
-    glEnableVertexAttribArray(rectShader.posAttrib);
+            // Track if any widget needs another frame
+            auto widgets = getOrCreateWidgetsFor(surf);
+            for (auto& w : widgets) {
+                feedback.needsFrame = w->draw({opacity->value()}) || feedback.needsFrame;
+            }
+        }
 
-    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+        feedback.needsFrame = feedback.needsFrame || !asyncResourceGatherer->gathered;
 
-    glDisableVertexAttribArray(rectShader.posAttrib);
+        glDisable(GL_BLEND);
+        popFb();
+        return feedback;
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "renderLock failed for output {}: {}", surf.m_outputRef.lock()->stringPort, e.what());
+        glDisable(GL_BLEND);
+        popFb();
+        return {};
+    }
+}
+void CRenderer::renderRect(const CBox& box, const CHyprColor& col, int rounding) {
+    try {
+        const auto ROUNDEDBOX = box.copy().round();
+        Mat3x3 matrix = projMatrix.projectBox(ROUNDEDBOX, HYPRUTILS_TRANSFORM_NORMAL, box.rot);
+        Mat3x3 glMatrix = projection.copy().multiply(matrix);
+
+        glUseProgram(rectShader.program);
+        glUniformMatrix3fv(rectShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
+        glUniform4f(rectShader.color, col.r * col.a, col.g * col.a, col.b * col.a, col.a);
+
+        const auto TOPLEFT = Vector2D(ROUNDEDBOX.x, ROUNDEDBOX.y);
+        const auto FULLSIZE = Vector2D(ROUNDEDBOX.width, ROUNDEDBOX.height);
+        glUniform2f(rectShader.topLeft, (float)TOPLEFT.x, (float)TOPLEFT.y);
+        glUniform2f(rectShader.fullSize, (float)FULLSIZE.x, (float)FULLSIZE.y);
+        glUniform1f(rectShader.radius, rounding);
+
+        glVertexAttribPointer(rectShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+        glEnableVertexAttribArray(rectShader.posAttrib);
+        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+        glDisableVertexAttribArray(rectShader.posAttrib);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "renderRect failed: {}", e.what());
+    }
 }
 
 void CRenderer::renderBorder(const CBox& box, const CGradientValueData& gradient, int thickness, int rounding, float alpha) {
-    const auto ROUNDEDBOX = box.copy().round();
-    Mat3x3     matrix     = projMatrix.projectBox(ROUNDEDBOX, HYPRUTILS_TRANSFORM_NORMAL, box.rot);
-    Mat3x3     glMatrix   = projection.copy().multiply(matrix);
-
-    glUseProgram(borderShader.program);
-
-    glUniformMatrix3fv(borderShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
-
-    glUniform4fv(borderShader.gradient, gradient.m_vColorsOkLabA.size(), (float*)gradient.m_vColorsOkLabA.data());
-    glUniform1i(borderShader.gradientLength, gradient.m_vColorsOkLabA.size() / 4);
-    glUniform1f(borderShader.angle, (int)(gradient.m_fAngle / (M_PI / 180.0)) % 360 * (M_PI / 180.0));
-    glUniform1f(borderShader.alpha, alpha);
-    glUniform1i(borderShader.gradient2Length, 0);
-
-    const auto TOPLEFT  = Vector2D(ROUNDEDBOX.x, ROUNDEDBOX.y);
-    const auto FULLSIZE = Vector2D(ROUNDEDBOX.width, ROUNDEDBOX.height);
-
-    glUniform2f(borderShader.topLeft, (float)TOPLEFT.x, (float)TOPLEFT.y);
-    glUniform2f(borderShader.fullSize, (float)FULLSIZE.x, (float)FULLSIZE.y);
-    glUniform2f(borderShader.fullSizeUntransformed, (float)box.width, (float)box.height);
-    glUniform1f(borderShader.radius, rounding);
-    glUniform1f(borderShader.radiusOuter, rounding);
-    glUniform1f(borderShader.thick, thickness);
-
-    glVertexAttribPointer(borderShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-    glVertexAttribPointer(borderShader.texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-
-    glEnableVertexAttribArray(borderShader.posAttrib);
-    glEnableVertexAttribArray(borderShader.texAttrib);
-
-    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-
-    glDisableVertexAttribArray(borderShader.posAttrib);
-    glDisableVertexAttribArray(borderShader.texAttrib);
+    try {
+        const auto ROUNDEDBOX = box.copy().round();
+        Mat3x3 matrix = projMatrix.projectBox(ROUNDEDBOX, HYPRUTILS_TRANSFORM_NORMAL, box.rot);
+        Mat3x3 glMatrix = projection.copy().multiply(matrix);
+
+        glUseProgram(borderShader.program);
+        glUniformMatrix3fv(borderShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
+        // Ensure gradient data is valid and non-empty to prevent buffer overruns
+        if (!gradient.m_vColorsOkLabA.empty()) {
+            glUniform4fv(borderShader.gradient, gradient.m_vColorsOkLabA.size(), (float*)gradient.m_vColorsOkLabA.data());
+            glUniform1i(borderShader.gradientLength, gradient.m_vColorsOkLabA.size() / 4);
+        } else {
+            // Fallback to a single transparent color if gradient is empty
+            float fallbackColor[4] = {0.0f, 0.0f, 0.0f, 0.0f};
+            glUniform4fv(borderShader.gradient, 1, fallbackColor);
+            glUniform1i(borderShader.gradientLength, 1);
+        }
+        glUniform1f(borderShader.angle, (int)(gradient.m_fAngle / (M_PI / 180.0)) % 360 * (M_PI / 180.0));
+        glUniform1f(borderShader.alpha, alpha);
+        glUniform1i(borderShader.gradient2Length, 0);
+
+        const auto TOPLEFT = Vector2D(ROUNDEDBOX.x, ROUNDEDBOX.y);
+        const auto FULLSIZE = Vector2D(ROUNDEDBOX.width, ROUNDEDBOX.height);
+        glUniform2f(borderShader.topLeft, (float)TOPLEFT.x, (float)TOPLEFT.y);
+        glUniform2f(borderShader.fullSize, (float)FULLSIZE.x, (float)FULLSIZE.y);
+        glUniform2f(borderShader.fullSizeUntransformed, (float)box.width, (float)box.height);
+        glUniform1f(borderShader.radius, rounding);
+        glUniform1f(borderShader.radiusOuter, rounding);
+        glUniform1f(borderShader.thick, thickness);
+
+        glVertexAttribPointer(borderShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+        glVertexAttribPointer(borderShader.texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+        glEnableVertexAttribArray(borderShader.posAttrib);
+        glEnableVertexAttribArray(borderShader.texAttrib);
+        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+        glDisableVertexAttribArray(borderShader.posAttrib);
+        glDisableVertexAttribArray(borderShader.texAttrib);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "renderBorder failed: {}", e.what());
+    }
 }
 
 void CRenderer::renderTexture(const CBox& box, const CTexture& tex, float a, int rounding, std::optional<eTransform> tr) {
-    const auto ROUNDEDBOX = box.copy().round();
-    Mat3x3     matrix     = projMatrix.projectBox(ROUNDEDBOX, tr.value_or(HYPRUTILS_TRANSFORM_FLIPPED_180), box.rot);
-    Mat3x3     glMatrix   = projection.copy().multiply(matrix);
-
-    CShader*   shader = &texShader;
-
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(tex.m_iTarget, tex.m_iTexID);
-
-    glUseProgram(shader->program);
-
-    glUniformMatrix3fv(shader->proj, 1, GL_TRUE, glMatrix.getMatrix().data());
-    glUniform1i(shader->tex, 0);
-    glUniform1f(shader->alpha, a);
-    const auto TOPLEFT  = Vector2D(ROUNDEDBOX.x, ROUNDEDBOX.y);
-    const auto FULLSIZE = Vector2D(ROUNDEDBOX.width, ROUNDEDBOX.height);
-
-    // Rounded corners
-    glUniform2f(shader->topLeft, TOPLEFT.x, TOPLEFT.y);
-    glUniform2f(shader->fullSize, FULLSIZE.x, FULLSIZE.y);
-    glUniform1f(shader->radius, rounding);
-
-    glUniform1i(shader->discardOpaque, 0);
-    glUniform1i(shader->discardAlpha, 0);
-    glUniform1i(shader->applyTint, 0);
-
-    glVertexAttribPointer(shader->posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-    glVertexAttribPointer(shader->texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+    try {
+        const auto ROUNDEDBOX = box.copy().round();
+        Mat3x3 matrix = projMatrix.projectBox(ROUNDEDBOX, tr.value_or(HYPRUTILS_TRANSFORM_FLIPPED_180), box.rot);
+        Mat3x3 glMatrix = projection.copy().multiply(matrix);
 
-    glEnableVertexAttribArray(shader->posAttrib);
-    glEnableVertexAttribArray(shader->texAttrib);
-
-    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-
-    glDisableVertexAttribArray(shader->posAttrib);
-    glDisableVertexAttribArray(shader->texAttrib);
-
-    glBindTexture(tex.m_iTarget, 0);
+        CShader* shader = &texShader;
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(tex.m_iTarget, tex.m_iTexID);
+        glUseProgram(shader->program);
+        glUniformMatrix3fv(shader->proj, 1, GL_TRUE, glMatrix.getMatrix().data());
+        glUniform1i(shader->tex, 0);
+        glUniform1f(shader->alpha, a);
+
+        const auto TOPLEFT = Vector2D(ROUNDEDBOX.x, ROUNDEDBOX.y);
+        const auto FULLSIZE = Vector2D(ROUNDEDBOX.width, ROUNDEDBOX.height);
+        glUniform2f(shader->topLeft, TOPLEFT.x, TOPLEFT.y);
+        glUniform2f(shader->fullSize, FULLSIZE.x, FULLSIZE.y);
+        glUniform1f(shader->radius, rounding);
+        glUniform1i(shader->discardOpaque, 0);
+        glUniform1i(shader->discardAlpha, 0);
+        glUniform1i(shader->applyTint, 0);
+
+        glVertexAttribPointer(shader->posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+        glVertexAttribPointer(shader->texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+        glEnableVertexAttribArray(shader->posAttrib);
+        glEnableVertexAttribArray(shader->texAttrib);
+        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+        glDisableVertexAttribArray(shader->posAttrib);
+        glDisableVertexAttribArray(shader->texAttrib);
+        glBindTexture(tex.m_iTarget, 0);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "renderTexture failed: {}", e.what());
+    }
 }
 
 void CRenderer::renderTextureMix(const CBox& box, const CTexture& tex, const CTexture& tex2, float a, float mixFactor, int rounding, std::optional<eTransform> tr) {
-    const auto ROUNDEDBOX = box.copy().round();
-    Mat3x3     matrix     = projMatrix.projectBox(ROUNDEDBOX, tr.value_or(HYPRUTILS_TRANSFORM_FLIPPED_180), box.rot);
-    Mat3x3     glMatrix   = projection.copy().multiply(matrix);
-
-    CShader*   shader = &texMixShader;
-
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(tex.m_iTarget, tex.m_iTexID);
-
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(tex2.m_iTarget, tex2.m_iTexID);
-
-    glUseProgram(shader->program);
-
-    glUniformMatrix3fv(shader->proj, 1, GL_TRUE, glMatrix.getMatrix().data());
-    glUniform1i(shader->tex, 0);
-    glUniform1i(shader->tex2, 1);
-    glUniform1f(shader->alpha, a);
-    glUniform1f(shader->mixFactor, mixFactor);
-    const auto TOPLEFT  = Vector2D(ROUNDEDBOX.x, ROUNDEDBOX.y);
-    const auto FULLSIZE = Vector2D(ROUNDEDBOX.width, ROUNDEDBOX.height);
-
-    // Rounded corners
-    glUniform2f(shader->topLeft, TOPLEFT.x, TOPLEFT.y);
-    glUniform2f(shader->fullSize, FULLSIZE.x, FULLSIZE.y);
-    glUniform1f(shader->radius, rounding);
+    try {
+        const auto ROUNDEDBOX = box.copy().round();
+        Mat3x3 matrix = projMatrix.projectBox(ROUNDEDBOX, tr.value_or(HYPRUTILS_TRANSFORM_FLIPPED_180), box.rot);
+        Mat3x3 glMatrix = projection.copy().multiply(matrix);
 
-    glUniform1i(shader->discardOpaque, 0);
-    glUniform1i(shader->discardAlpha, 0);
-    glUniform1i(shader->applyTint, 0);
-
-    glVertexAttribPointer(shader->posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-    glVertexAttribPointer(shader->texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-
-    glEnableVertexAttribArray(shader->posAttrib);
-    glEnableVertexAttribArray(shader->texAttrib);
-
-    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-
-    glDisableVertexAttribArray(shader->posAttrib);
-    glDisableVertexAttribArray(shader->texAttrib);
-
-    glBindTexture(tex.m_iTarget, 0);
+        CShader* shader = &texMixShader;
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(tex.m_iTarget, tex.m_iTexID);
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(tex2.m_iTarget, tex2.m_iTexID);
+        glUseProgram(shader->program);
+        glUniformMatrix3fv(shader->proj, 1, GL_TRUE, glMatrix.getMatrix().data());
+        glUniform1i(shader->tex, 0);
+        glUniform1i(shader->tex2, 1);
+        glUniform1f(shader->alpha, a);
+        glUniform1f(shader->mixFactor, mixFactor);
+        const auto TOPLEFT = Vector2D(ROUNDEDBOX.x, ROUNDEDBOX.y);
+        const auto FULLSIZE = Vector2D(ROUNDEDBOX.width, ROUNDEDBOX.height);
+        glUniform2f(shader->topLeft, TOPLEFT.x, TOPLEFT.y);
+        glUniform2f(shader->fullSize, FULLSIZE.x, FULLSIZE.y);
+        glUniform1f(shader->radius, rounding);
+        glUniform1i(shader->discardOpaque, 0);
+        glUniform1i(shader->discardAlpha, 0);
+        glUniform1i(shader->applyTint, 0);
+
+        glVertexAttribPointer(shader->posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+        glVertexAttribPointer(shader->texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+        glEnableVertexAttribArray(shader->posAttrib);
+        glEnableVertexAttribArray(shader->texAttrib);
+        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+        glDisableVertexAttribArray(shader->posAttrib);
+        glDisableVertexAttribArray(shader->texAttrib);
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(tex2.m_iTarget, 0);
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(tex.m_iTarget, 0);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "renderTextureMix failed: {}", e.what());
+    }
 }
+
 template <class Widget>
 static void createWidget(std::vector<SP<IWidget>>& widgets) {
     const auto W = makeShared<Widget>();
@@ -446,161 +461,147 @@ static void createWidget(std::vector<SP<IWidget>>& widgets) {
 }
 
 std::vector<SP<IWidget>>& CRenderer::getOrCreateWidgetsFor(const CSessionLockSurface& surf) {
-    RASSERT(surf.m_outputID != OUTPUT_INVALID, "Invalid output ID!");
-
-    if (!widgets.contains(surf.m_outputID)) {
-        auto CWIDGETS = g_pConfigManager->getWidgetConfigs();
-
-        std::ranges::sort(CWIDGETS, [](CConfigManager::SWidgetConfig& a, CConfigManager::SWidgetConfig& b) {
-            return std::any_cast<Hyprlang::INT>(a.values.at("zindex")) < std::any_cast<Hyprlang::INT>(b.values.at("zindex"));
-        });
-
-        const auto POUTPUT = surf.m_outputRef.lock();
-        for (auto& c : CWIDGETS) {
-            if (!c.monitor.empty() && c.monitor != POUTPUT->stringPort && !POUTPUT->stringDesc.starts_with(c.monitor) && !POUTPUT->stringDesc.starts_with("desc:" + c.monitor))
-                continue;
-
-            // by type
-            if (c.type == "background") {
-                createWidget<CBackground>(widgets[surf.m_outputID]);
-            } else if (c.type == "input-field") {
-                createWidget<CPasswordInputField>(widgets[surf.m_outputID]);
-            } else if (c.type == "label") {
-                createWidget<CLabel>(widgets[surf.m_outputID]);
-            } else if (c.type == "shape") {
-                createWidget<CShape>(widgets[surf.m_outputID]);
-            } else if (c.type == "image") {
-                createWidget<CImage>(widgets[surf.m_outputID]);
-            } else {
-                Debug::log(ERR, "Unknown widget type: {}", c.type);
-                continue;
-            }
+    try {
+        RASSERT(surf.m_outputID != OUTPUT_INVALID, "Invalid output ID!");
+        if (!widgets.contains(surf.m_outputID)) {
+            auto CWIDGETS = g_pConfigManager->getWidgetConfigs();
+            // Sort widgets by zindex to ensure correct render order
+            std::ranges::sort(CWIDGETS, [](const CConfigManager::SWidgetConfig& a, const CConfigManager::SWidgetConfig& b) {
+                int zindexA = 0, zindexB = 0;
+                try {
+                    zindexA = std::any_cast<Hyprlang::INT>(a.values.at("zindex"));
+                } catch (...) {
+                    Debug::log(WARN, "Widget {} missing zindex, defaulting to 0", a.type);
+                }
+                try {
+                    zindexB = std::any_cast<Hyprlang::INT>(b.values.at("zindex"));
+                } catch (...) {
+                    Debug::log(WARN, "Widget {} missing zindex, defaulting to 0", b.type);
+                }
+                return zindexA < zindexB;
+            });
+
+            const auto POUTPUT = surf.m_outputRef.lock();
+            for (auto& c : CWIDGETS) {
+                if (!c.monitor.empty() && c.monitor != POUTPUT->stringPort && 
+                    !POUTPUT->stringDesc.starts_with(c.monitor) && 
+                    !POUTPUT->stringDesc.starts_with("desc:" + c.monitor))
+                    continue;
 
-            widgets[surf.m_outputID].back()->configure(c.values, POUTPUT);
+                if (c.type == "background") {
+                    createWidget<CBackground>(widgets[surf.m_outputID]);
+                } else if (c.type == "input-field") {
+                    createWidget<CPasswordInputField>(widgets[surf.m_outputID]);
+                } else if (c.type == "label") {
+                    createWidget<CLabel>(widgets[surf.m_outputID]);
+                } else if (c.type == "shape") {
+                    createWidget<CShape>(widgets[surf.m_outputID]);
+                } else if (c.type == "image") {
+                    createWidget<CImage>(widgets[surf.m_outputID]);
+                } else {
+                    Debug::log(ERR, "Unknown widget type: {}", c.type);
+                    continue;
+                }
+                try {
+                    widgets[surf.m_outputID].back()->configure(c.values, POUTPUT);
+                } catch (const std::exception& e) {
+                    Debug::log(ERR, "Failed to configure widget type {}: {}", c.type, e.what());
+                    widgets[surf.m_outputID].pop_back(); // Remove faulty widget
+                }
+            }
+            Debug::log(LOG, "Created {} widgets for output {}", widgets[surf.m_outputID].size(), POUTPUT->stringPort);
         }
+        return widgets[surf.m_outputID];
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "getOrCreateWidgetsFor failed for output {}: {}", surf.m_outputRef.lock()->stringPort, e.what());
+        static std::vector<SP<IWidget>> empty;
+        return empty;
     }
-
-    return widgets[surf.m_outputID];
 }
-
 void CRenderer::blurFB(const CFramebuffer& outfb, SBlurParams params) {
-    glDisable(GL_BLEND);
-    glDisable(GL_STENCIL_TEST);
-
-    CBox box{0, 0, outfb.m_vSize.x, outfb.m_vSize.y};
-    box.round();
-    Mat3x3       matrix   = projMatrix.projectBox(box, HYPRUTILS_TRANSFORM_NORMAL, 0);
-    Mat3x3       glMatrix = projection.copy().multiply(matrix);
-
-    CFramebuffer mirrors[2];
-    mirrors[0].alloc(outfb.m_vSize.x, outfb.m_vSize.y, true);
-    mirrors[1].alloc(outfb.m_vSize.x, outfb.m_vSize.y, true);
+    try {
+        glDisable(GL_BLEND);
+        glDisable(GL_STENCIL_TEST);
 
-    CFramebuffer* currentRenderToFB = &mirrors[0];
+        CBox box{0, 0, outfb.m_vSize.x, outfb.m_vSize.y};
+        box.round();
+        Mat3x3 matrix = projMatrix.projectBox(box, HYPRUTILS_TRANSFORM_NORMAL, 0);
+        Mat3x3 glMatrix = projection.copy().multiply(matrix);
 
-    // Begin with base color adjustments - global brightness and contrast
-    // TODO: make this a part of the first pass maybe to save on a drawcall?
-    {
-        mirrors[1].bind();
+        CFramebuffer mirrors[2];
+        mirrors[0].alloc(outfb.m_vSize.x, outfb.m_vSize.y, true);
+        mirrors[1].alloc(outfb.m_vSize.x, outfb.m_vSize.y, true);
 
-        glActiveTexture(GL_TEXTURE0);
-
-        glBindTexture(outfb.m_cTex.m_iTarget, outfb.m_cTex.m_iTexID);
-
-        glTexParameteri(outfb.m_cTex.m_iTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-
-        glUseProgram(blurPrepareShader.program);
-
-        glUniformMatrix3fv(blurPrepareShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
-        glUniform1f(blurPrepareShader.contrast, params.contrast);
-        glUniform1f(blurPrepareShader.brightness, params.brightness);
-        glUniform1i(blurPrepareShader.tex, 0);
-
-        glVertexAttribPointer(blurPrepareShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-        glVertexAttribPointer(blurPrepareShader.texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-
-        glEnableVertexAttribArray(blurPrepareShader.posAttrib);
-        glEnableVertexAttribArray(blurPrepareShader.texAttrib);
-
-        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-
-        glDisableVertexAttribArray(blurPrepareShader.posAttrib);
-        glDisableVertexAttribArray(blurPrepareShader.texAttrib);
-
-        currentRenderToFB = &mirrors[1];
-    }
+        CFramebuffer* currentRenderToFB = &mirrors[0];
 
-    // declare the draw func
-    auto drawPass = [&](CShader* pShader) {
-        if (currentRenderToFB == &mirrors[0])
+        {
             mirrors[1].bind();
-        else
-            mirrors[0].bind();
-
-        glActiveTexture(GL_TEXTURE0);
-
-        glBindTexture(currentRenderToFB->m_cTex.m_iTarget, currentRenderToFB->m_cTex.m_iTexID);
-
-        glTexParameteri(currentRenderToFB->m_cTex.m_iTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-
-        glUseProgram(pShader->program);
-
-        // prep two shaders
-        glUniformMatrix3fv(pShader->proj, 1, GL_TRUE, glMatrix.getMatrix().data());
-        glUniform1f(pShader->radius, params.size);
-        if (pShader == &blurShader1) {
-            glUniform2f(blurShader1.halfpixel, 0.5f / (outfb.m_vSize.x / 2.f), 0.5f / (outfb.m_vSize.y / 2.f));
-            glUniform1i(blurShader1.passes, params.passes);
-            glUniform1f(blurShader1.vibrancy, params.vibrancy);
-            glUniform1f(blurShader1.vibrancy_darkness, params.vibrancy_darkness);
-        } else
-            glUniform2f(blurShader2.halfpixel, 0.5f / (outfb.m_vSize.x * 2.f), 0.5f / (outfb.m_vSize.y * 2.f));
-        glUniform1i(pShader->tex, 0);
-
-        glVertexAttribPointer(pShader->posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-        glVertexAttribPointer(pShader->texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-
-        glEnableVertexAttribArray(pShader->posAttrib);
-        glEnableVertexAttribArray(pShader->texAttrib);
-
-        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-
-        glDisableVertexAttribArray(pShader->posAttrib);
-        glDisableVertexAttribArray(pShader->texAttrib);
-
-        if (currentRenderToFB != &mirrors[0])
-            currentRenderToFB = &mirrors[0];
-        else
+            glActiveTexture(GL_TEXTURE0);
+            glBindTexture(outfb.m_cTex.m_iTarget, outfb.m_cTex.m_iTexID);
+            glTexParameteri(outfb.m_cTex.m_iTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glUseProgram(blurPrepareShader.program);
+            glUniformMatrix3fv(blurPrepareShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
+            glUniform1f(blurPrepareShader.contrast, params.contrast);
+            glUniform1f(blurPrepareShader.brightness, params.brightness);
+            glUniform1i(blurPrepareShader.tex, 0);
+            glVertexAttribPointer(blurPrepareShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+            glEnableVertexAttribArray(blurPrepareShader.posAttrib);
+            glVertexAttribPointer(blurPrepareShader.texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+            glEnableVertexAttribArray(blurPrepareShader.texAttrib);
+            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+            glDisableVertexAttribArray(blurPrepareShader.posAttrib);
+            glDisableVertexAttribArray(blurPrepareShader.texAttrib);
             currentRenderToFB = &mirrors[1];
-    };
-
-    // draw the things.
-    // first draw is swap -> mirr
-    mirrors[0].bind();
-    glBindTexture(mirrors[1].m_cTex.m_iTarget, mirrors[1].m_cTex.m_iTexID);
+        }
 
-    for (int i = 1; i <= params.passes; ++i) {
-        drawPass(&blurShader1); // down
-    }
+        auto drawPass = [&](CShader* pShader) {
+            if (currentRenderToFB == &mirrors[0])
+                mirrors[1].bind();
+            else
+                mirrors[0].bind();
+            glActiveTexture(GL_TEXTURE0);
+            glBindTexture(currentRenderToFB->m_cTex.m_iTarget, currentRenderToFB->m_cTex.m_iTexID);
+            glTexParameteri(currentRenderToFB->m_cTex.m_iTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glUseProgram(pShader->program);
+            glUniformMatrix3fv(pShader->proj, 1, GL_TRUE, glMatrix.getMatrix().data());
+            glUniform1f(pShader->radius, params.size);
+            if (pShader == &blurShader1) {
+                glUniform2f(blurShader1.halfpixel, 0.5f / (outfb.m_vSize.x / 2.f), 0.5f / (outfb.m_vSize.y / 2.f));
+                glUniform1i(blurShader1.passes, params.passes);
+                glUniform1f(blurShader1.vibrancy, params.vibrancy);
+                glUniform1f(blurShader1.vibrancy_darkness, params.vibrancy_darkness);
+            } else {
+                glUniform2f(blurShader2.halfpixel, 0.5f / (outfb.m_vSize.x * 2.f), 0.5f / (outfb.m_vSize.y * 2.f));
+            }
+            glUniform1i(pShader->tex, 0);
+            glVertexAttribPointer(pShader->posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+            glEnableVertexAttribArray(pShader->posAttrib);
+            glVertexAttribPointer(pShader->texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
+            glEnableVertexAttribArray(pShader->texAttrib);
+            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+            glDisableVertexAttribArray(pShader->posAttrib);
+            glDisableVertexAttribArray(pShader->texAttrib);
+            currentRenderToFB = (currentRenderToFB == &mirrors[0]) ? &mirrors[1] : &mirrors[0];
+        };
+
+        mirrors[0].bind();
+        glBindTexture(mirrors[1].m_cTex.m_iTarget, mirrors[1].m_cTex.m_iTexID);
+        for (int i = 1; i <= params.passes; ++i) {
+            drawPass(&blurShader1);
+        }
+        for (int i = params.passes - 1; i >= 0; --i) {
+            drawPass(&blurShader2);
+        }
 
-    for (int i = params.passes - 1; i >= 0; --i) {
-        drawPass(&blurShader2); // up
-    }
-        // finalize the image
         {
             if (currentRenderToFB == &mirrors[0])
                 mirrors[1].bind();
             else
                 mirrors[0].bind();
-    
             glActiveTexture(GL_TEXTURE0);
-    
             glBindTexture(currentRenderToFB->m_cTex.m_iTarget, currentRenderToFB->m_cTex.m_iTexID);
-    
             glTexParameteri(currentRenderToFB->m_cTex.m_iTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    
             glUseProgram(blurFinishShader.program);
-    
             glUniformMatrix3fv(blurFinishShader.proj, 1, GL_TRUE, glMatrix.getMatrix().data());
             glUniform1f(blurFinishShader.noise, params.noise);
             glUniform1f(blurFinishShader.brightness, params.brightness);
@@ -608,70 +609,167 @@ void CRenderer::blurFB(const CFramebuffer& outfb, SBlurParams params) {
             if (params.colorize.has_value())
                 glUniform3f(blurFinishShader.colorizeTint, params.colorize->r, params.colorize->g, params.colorize->b);
             glUniform1f(blurFinishShader.boostA, params.boostA);
-    
             glUniform1i(blurFinishShader.tex, 0);
-    
             glVertexAttribPointer(blurFinishShader.posAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-            glVertexAttribPointer(blurFinishShader.texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
-    
             glEnableVertexAttribArray(blurFinishShader.posAttrib);
+            glVertexAttribPointer(blurFinishShader.texAttrib, 2, GL_FLOAT, GL_FALSE, 0, fullVerts);
             glEnableVertexAttribArray(blurFinishShader.texAttrib);
-    
             glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-    
             glDisableVertexAttribArray(blurFinishShader.posAttrib);
             glDisableVertexAttribArray(blurFinishShader.texAttrib);
-    
-            if (currentRenderToFB != &mirrors[0])
-                currentRenderToFB = &mirrors[0];
-            else
-                currentRenderToFB = &mirrors[1];
+            currentRenderToFB = (currentRenderToFB == &mirrors[0]) ? &mirrors[1] : &mirrors[0];
         }
-    
-        // finish
+
         outfb.bind();
         renderTexture(box, currentRenderToFB->m_cTex, 1.0, 0, HYPRUTILS_TRANSFORM_NORMAL);
-    
+        glEnable(GL_BLEND);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "blurFB failed: {}", e.what());
+        outfb.bind();
         glEnable(GL_BLEND);
     }
-    
-    void CRenderer::pushFb(GLint fb) {
+}
+
+void CRenderer::pushFb(GLint fb) {
+    try {
         boundFBs.push_back(fb);
         glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fb);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "pushFb failed: {}", e.what());
     }
-    
-    void CRenderer::popFb() {
-        boundFBs.pop_back();
-        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, boundFBs.empty() ? 0 : boundFBs.back());
+}
+
+void CRenderer::popFb() {
+    try {
+        if (!boundFBs.empty()) {
+            boundFBs.pop_back();
+            glBindFramebuffer(GL_DRAW_FRAMEBUFFER, boundFBs.empty() ? 0 : boundFBs.back());
+        }
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "popFb failed: {}", e.what());
     }
-    
-    void CRenderer::removeWidgetsFor(OUTPUTID id) {
+}
+
+void CRenderer::removeWidgetsFor(OUTPUTID id) {
+    try {
         widgets.erase(id);
+        Debug::log(LOG, "Removed widgets for output ID {}", id);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "removeWidgetsFor failed for ID {}: {}", id, e.what());
     }
-    
-    void CRenderer::reconfigureWidgetsFor(OUTPUTID id) {
-        // TODO: reconfigure widgets by just calling their configure method again.
-        // Requires a way to get a widgets config properties.
-        // I think the best way would be to store the anonymos key of the widget config.
+}
+
+void CRenderer::reconfigureWidgetsFor(OUTPUTID id) {
+    try {
         removeWidgetsFor(id);
+        Debug::log(LOG, "Reconfigured widgets for output ID {}", id);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "reconfigureWidgetsFor failed for ID {}: {}", id, e.what());
     }
-    
-    void CRenderer::startFadeIn() {
+}
+
+void CRenderer::startFadeIn() {
+    try {
         Debug::log(LOG, "Starting fade in");
         *opacity = 1.f;
-    
         opacity->setCallbackOnEnd([this](auto) { opacity->setConfig(g_pConfigManager->m_AnimationTree.getConfig("fadeOut")); }, true);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "startFadeIn failed: {}", e.what());
     }
-    
-    void CRenderer::startFadeOut(bool unlock, bool immediate) {
+}
+
+void CRenderer::startFadeOut(bool unlock, bool immediate) {
+    try {
         if (immediate)
             opacity->setValueAndWarp(0.f);
         else
             *opacity = 0.f;
-    
         if (unlock)
-            opacity->setCallbackOnEnd([this](auto) {
-                stopMpvpaper();  // Stop mpvpaper when fading out
-                g_pHyprlock->releaseSessionLock();
-            }, true);
-    }
\ No newline at end of file
+            opacity->setCallbackOnEnd([](auto) { g_pHyprlock->releaseSessionLock(); }, true);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "startFadeOut failed: {}", e.what());
+    }
+}
+
+bool CRenderer::startMpvpaper(const std::string& monitor, const std::string& videoPath) {
+    try {
+        std::lock_guard<std::mutex> lock(mpvpaperMutex);
+        if (mpvpaperPids.find(monitor) != mpvpaperPids.end()) {
+            Debug::log(LOG, "mpvpaper already running for monitor {}, PID {}", monitor, mpvpaperPids[monitor]);
+            return true;
+        }
+        Debug::log(LOG, "Starting mpvpaper for monitor {} with video {}", monitor, videoPath);
+        pid_t pid = fork();
+        if (pid == 0) {
+            // Redirect stderr to log file for debugging
+            freopen("/tmp/mpvpaper.log", "w", stderr);
+            // Use minimal mpvpaper options, relying on default Wayland surface layering
+            execlp("mpvpaper", "mpvpaper", "-o", "loop panscan=1.0 mute=yes", monitor.c_str(), videoPath.c_str(), (char*)nullptr);
+            Debug::log(ERR, "execlp failed for mpvpaper on monitor {} with video {}: errno {}", monitor, videoPath, errno);
+            _exit(1);
+        } else if (pid > 0) {
+            mpvpaperPids[monitor] = pid;
+            mpvpaperVideoPaths[monitor] = videoPath;
+            Debug::log(LOG, "Started mpvpaper for monitor {} with PID {}", monitor, pid);
+            return true;
+        } else {
+            Debug::log(ERR, "Fork failed for mpvpaper on monitor {}: errno {}", monitor, errno);
+            return false;
+        }
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "startMpvpaper failed for monitor {}: {}", monitor, e.what());
+        return false;
+    }
+}
+
+void CRenderer::stopMpvpaper() {
+    try {
+        std::lock_guard<std::mutex> lock(mpvpaperMutex);
+        for (auto it = mpvpaperPids.begin(); it != mpvpaperPids.end();) {
+            pid_t pid = it->second;
+            if (pid > 0) {
+                Debug::log(LOG, "Stopping mpvpaper for monitor {} with PID {}", it->first, pid);
+                kill(pid, SIGTERM);
+                int status;
+                waitpid(pid, &status, 0);
+                if (WIFEXITED(status)) {
+                    Debug::log(LOG, "mpvpaper PID {} exited with status {}", pid, WEXITSTATUS(status));
+                } else if (WIFSIGNALED(status)) {
+                    Debug::log(WARN, "mpvpaper PID {} terminated by signal {}", pid, WTERMSIG(status));
+                }
+            }
+            it = mpvpaperPids.erase(it);
+        }
+        mpvpaperVideoPaths.clear();
+        Debug::log(LOG, "All mpvpaper processes stopped");
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "stopMpvpaper failed: {}", e.what());
+    }
+}
+
+void CRenderer::stopMpvpaper(const std::string& monitor) {
+    try {
+        std::lock_guard<std::mutex> lock(mpvpaperMutex);
+        auto it = mpvpaperPids.find(monitor);
+        if (it != mpvpaperPids.end()) {
+            pid_t pid = it->second;
+            if (pid > 0) {
+                Debug::log(LOG, "Stopping mpvpaper for monitor {} with PID {}", monitor, pid);
+                kill(pid, SIGTERM);
+                int status;
+                waitpid(pid, &status, 0);
+                if (WIFEXITED(status)) {
+                    Debug::log(LOG, "mpvpaper PID {} exited with status {}", pid, WEXITSTATUS(status));
+                } else if (WIFSIGNALED(status)) {
+                    Debug::log(WARN, "mpvpaper PID {} terminated by signal {}", pid, WTERMSIG(status));
+                }
+            }
+            mpvpaperPids.erase(it);
+            mpvpaperVideoPaths.erase(monitor);
+        } else {
+            Debug::log(LOG, "No mpvpaper process found for monitor {}", monitor);
+        }
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "stopMpvpaper for monitor {} failed: {}", monitor, e.what());
+    }
+}
\ No newline at end of file
diff --git a/src/renderer/Renderer.hpp b/src/renderer/Renderer.hpp
index 9d32de53..78cc6225 100644
--- a/src/renderer/Renderer.hpp
+++ b/src/renderer/Renderer.hpp
@@ -2,6 +2,7 @@
 
 #include <chrono>
 #include <optional>
+#include <mutex> // Added for mpvpaperMutex
 #include "Shader.hpp"
 #include "../defines.hpp"
 #include "../core/LockSurface.hpp"
@@ -11,6 +12,8 @@
 #include "../config/ConfigDataValues.hpp"
 #include "widgets/IWidget.hpp"
 #include "Framebuffer.hpp"
+#include <map>
+#include <string>
 
 typedef std::unordered_map<OUTPUTID, std::vector<SP<IWidget>>> widgetMap_t;
 
@@ -34,8 +37,13 @@ class CRenderer {
     void            renderRect(const CBox& box, const CHyprColor& col, int rounding = 0);
     void            renderBorder(const CBox& box, const CGradientValueData& gradient, int thickness, int rounding = 0, float alpha = 1.0);
     void            renderTexture(const CBox& box, const CTexture& tex, float a = 1.0, int rounding = 0, std::optional<eTransform> tr = {});
-    void renderTextureMix(const CBox& box, const CTexture& tex, const CTexture& tex2, float a = 1.0, float mixFactor = 0.0, int rounding = 0, std::optional<eTransform> tr = {});
-    void blurFB(const CFramebuffer& outfb, SBlurParams params);
+    void            renderTextureMix(const CBox& box, const CTexture& tex, const CTexture& tex2, float a = 1.0, float mixFactor = 0.0, int rounding = 0, std::optional<eTransform> tr = {});
+    void            blurFB(const CFramebuffer& outfb, SBlurParams params);
+
+    // Added methods for layered rendering
+    void            renderBackground(const CSessionLockSurface& surf, float opacity);
+    void            renderShapes(const CSessionLockSurface& surf, float opacity);
+    void            renderInputFields(const CSessionLockSurface& surf, float opacity);
 
     UP<CAsyncResourceGatherer>            asyncResourceGatherer;
     std::chrono::system_clock::time_point firstFullFrameTime;
@@ -49,6 +57,10 @@ class CRenderer {
     void                                  startFadeIn();
     void                                  startFadeOut(bool unlock = false, bool immediate = true);
 
+    bool                                  startMpvpaper(const std::string& monitor, const std::string& videoPath);
+    void                                  stopMpvpaper();
+    void                                  stopMpvpaper(const std::string& monitor);
+
   private:
     widgetMap_t               widgets;
 
@@ -68,7 +80,11 @@ class CRenderer {
 
     PHLANIMVAR<float>         opacity;
 
+    std::map<std::string, pid_t> mpvpaperPids;
+    std::map<std::string, std::string> mpvpaperVideoPaths;
+    std::mutex                mpvpaperMutex; // Added for safe PID management
+
     std::vector<GLint>        boundFBs;
 };
 
-inline UP<CRenderer> g_pRenderer;
+inline UP<CRenderer> g_pRenderer;
\ No newline at end of file
diff --git a/src/renderer/widgets/Background.cpp b/src/renderer/widgets/Background.cpp
index c75026c0..e0f659c9 100644
--- a/src/renderer/widgets/Background.cpp
+++ b/src/renderer/widgets/Background.cpp
@@ -9,75 +9,297 @@
 #include <memory>
 #include <GLES3/gl32.h>
 
+extern UP<CRenderer> g_pRenderer;
+
 CBackground::~CBackground() {
     reset();
+    if (isVideoBackground && !monitor.empty()) {
+        g_pRenderer->stopMpvpaper(monitor);
+        isVideoBackground = false;
+    }
 }
 
 void CBackground::registerSelf(const SP<CBackground>& self) {
     m_self = self;
 }
 
-void CBackground::configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput) {
-    reset();
+std::string CBackground::type() const {
+    return "background";
+}
 
+void CBackground::configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput) {
     try {
-        color             = std::any_cast<Hyprlang::INT>(props.at("color"));
-        blurPasses        = std::any_cast<Hyprlang::INT>(props.at("blur_passes"));
-        blurSize          = std::any_cast<Hyprlang::INT>(props.at("blur_size"));
-        vibrancy          = std::any_cast<Hyprlang::FLOAT>(props.at("vibrancy"));
-        vibrancy_darkness = std::any_cast<Hyprlang::FLOAT>(props.at("vibrancy_darkness"));
-        noise             = std::any_cast<Hyprlang::FLOAT>(props.at("noise"));
-        brightness        = std::any_cast<Hyprlang::FLOAT>(props.at("brightness"));
-        contrast          = std::any_cast<Hyprlang::FLOAT>(props.at("contrast"));
-        path              = std::any_cast<Hyprlang::STRING>(props.at("path"));
-        reloadCommand     = std::any_cast<Hyprlang::STRING>(props.at("reload_cmd"));
-        reloadTime        = std::any_cast<Hyprlang::INT>(props.at("reload_time"));
-        crossFadeTime     = std::any_cast<Hyprlang::FLOAT>(props.at("crossfade_time"));
-
-    } catch (const std::bad_any_cast& e) {
-        RASSERT(false, "Failed to construct CBackground: {}", e.what());
-    } catch (const std::out_of_range& e) {
-        RASSERT(false, "Missing propperty for CBackground: {}", e.what());
-    }
+        reset();
+
+        // Parse properties
+        if (props.contains("color")) {
+            try {
+                const auto& colorVal = props.at("color");
+                if (colorVal.type() == typeid(Hyprlang::STRING)) {
+                    std::string colorStr = std::any_cast<Hyprlang::STRING>(colorVal);
+                    if (colorStr.starts_with("0x") || colorStr.starts_with("#"))
+                        colorStr = colorStr.substr(2);
+                    uint64_t colorValue = std::stoull(colorStr, nullptr, 16);
+                    color = CHyprColor(colorValue);
+                } else if (colorVal.type() == typeid(Hyprlang::INT)) {
+                    uint64_t colorValue = std::any_cast<Hyprlang::INT>(colorVal);
+                    color = CHyprColor(colorValue);
+                } else {
+                    throw std::bad_any_cast();
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse color: {}", e.what());
+                color = CHyprColor(0, 0, 0, 0); // Transparent default for video backgrounds
+            }
+        } else {
+            color = CHyprColor(0, 0, 0, 0);
+        }
 
-    isScreenshot = path == "screenshot";
+        blurPasses = 3;
+        if (props.contains("blur_passes")) {
+            try {
+                const auto& val = props.at("blur_passes");
+                if (val.type() == typeid(Hyprlang::INT)) {
+                    blurPasses = std::any_cast<Hyprlang::INT>(val);
+                } else {
+                    Debug::log(WARN, "blur_passes has unexpected type, using default: 3");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse blur_passes: {}", e.what());
+            }
+        }
 
-    // Check if the path is an MP4 file
-    if (path.ends_with(".mp4")) {
-        isVideoBackground = true;
-        videoPath = path;
-        Debug::log(LOG, "Detected video background: {}", path);
-        resourceID = "";  // Skip loading a static texture since we'll use mpvpaper
-    } else {
-        isVideoBackground = false;
-        videoPath = "";
-        resourceID = isScreenshot ? CScreencopyFrame::getResourceId(pOutput) : (!path.empty() ? "background:" + path : "");
-    }
+        blurSize = 10;
+        if (props.contains("blur_size")) {
+            try {
+                const auto& val = props.at("blur_size");
+                if (val.type() == typeid(Hyprlang::INT)) {
+                    blurSize = std::any_cast<Hyprlang::INT>(val);
+                } else {
+                    Debug::log(WARN, "blur_size has unexpected type, using default: 10");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse blur_size: {}", e.what());
+            }
+        }
 
-    viewport   = pOutput->getViewport();
-    outputPort = pOutput->stringPort;
-    transform  = isScreenshot ? wlTransformToHyprutils(invertTransform(pOutput->transform)) : HYPRUTILS_TRANSFORM_NORMAL;
+        vibrancy = 0.1696f;
+        if (props.contains("vibrancy")) {
+            try {
+                const auto& val = props.at("vibrancy");
+                if (val.type() == typeid(Hyprlang::FLOAT)) {
+                    vibrancy = std::any_cast<Hyprlang::FLOAT>(val);
+                } else if (val.type() == typeid(Hyprlang::INT)) {
+                    vibrancy = static_cast<float>(std::any_cast<Hyprlang::INT>(val));
+                } else {
+                    Debug::log(WARN, "vibrancy has unexpected type, using default: 0.1696");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse vibrancy: {}", e.what());
+            }
+        }
 
-    if (isScreenshot && !isVideoBackground) {
-        // When the initial gather of the asyncResourceGatherer is completed (ready), all DMAFrames are available.
-        // Dynamic ones are tricky, because a screencopy would copy hyprlock itself.
-        if (g_pRenderer->asyncResourceGatherer->gathered) {
-            if (!g_pRenderer->asyncResourceGatherer->getAssetByID(resourceID))
-                resourceID = ""; // Fallback to solid color (background:color)
+        vibrancy_darkness = 0.f;
+        if (props.contains("vibrancy_darkness")) {
+            try {
+                const auto& val = props.at("vibrancy_darkness");
+                if (val.type() == typeid(Hyprlang::FLOAT)) {
+                    vibrancy_darkness = std::any_cast<Hyprlang::FLOAT>(val);
+                } else if (val.type() == typeid(Hyprlang::INT)) {
+                    vibrancy_darkness = static_cast<float>(std::any_cast<Hyprlang::INT>(val));
+                } else {
+                    Debug::log(WARN, "vibrancy_darkness has unexpected type, using default: 0");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse vibrancy_darkness: {}", e.what());
+            }
         }
 
-        if (!g_pHyprlock->getScreencopy()) {
-            Debug::log(ERR, "No screencopy support! path=screenshot won't work. Falling back to background color.");
-            resourceID = "";
+        noise = 0.0117f;
+        if (props.contains("noise")) {
+            try {
+                const auto& val = props.at("noise");
+                if (val.type() == typeid(Hyprlang::FLOAT)) {
+                    noise = std::any_cast<Hyprlang::FLOAT>(val);
+                } else if (val.type() == typeid(Hyprlang::INT)) {
+                    noise = static_cast<float>(std::any_cast<Hyprlang::INT>(val));
+                } else {
+                    Debug::log(WARN, "noise has unexpected type, using default: 0.0117");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse noise: {}", e.what());
+            }
+        }
+
+        brightness = 0.8172f;
+        if (props.contains("brightness")) {
+            try {
+                const auto& val = props.at("brightness");
+                if (val.type() == typeid(Hyprlang::FLOAT)) {
+                    brightness = std::any_cast<Hyprlang::FLOAT>(val);
+                } else if (val.type() == typeid(Hyprlang::INT)) {
+                    brightness = static_cast<float>(std::any_cast<Hyprlang::INT>(val));
+                } else {
+                    Debug::log(WARN, "brightness has unexpected type, using default: 0.8172");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse brightness: {}", e.what());
+            }
+        }
+
+        contrast = 0.8916f;
+        if (props.contains("contrast")) {
+            try {
+                const auto& val = props.at("contrast");
+                if (val.type() == typeid(Hyprlang::FLOAT)) {
+                    contrast = std::any_cast<Hyprlang::FLOAT>(val);
+                } else if (val.type() == typeid(Hyprlang::INT)) {
+                    contrast = static_cast<float>(std::any_cast<Hyprlang::INT>(val));
+                } else {
+                    Debug::log(WARN, "contrast has unexpected type, using default: 0.8916");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse contrast: {}", e.what());
+            }
+        }
+
+        path = "";
+        if (props.contains("path")) {
+            try {
+                const auto& val = props.at("path");
+                if (val.type() == typeid(Hyprlang::STRING)) {
+                    path = std::any_cast<Hyprlang::STRING>(val);
+                } else {
+                    Debug::log(WARN, "path has unexpected type, using default: empty");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse path: {}", e.what());
+            }
+        }
+
+        reloadCommand = "";
+        if (props.contains("reload_cmd")) {
+            try {
+                const auto& val = props.at("reload_cmd");
+                if (val.type() == typeid(Hyprlang::STRING)) {
+                    reloadCommand = std::any_cast<Hyprlang::STRING>(val);
+                } else {
+                    Debug::log(WARN, "reload_cmd has unexpected type, using default: empty");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse reload_cmd: {}", e.what());
+            }
+        }
+
+        reloadTime = -1;
+        if (props.contains("reload_time")) {
+            try {
+                const auto& val = props.at("reload_time");
+                if (val.type() == typeid(Hyprlang::INT)) {
+                    reloadTime = std::any_cast<Hyprlang::INT>(val);
+                } else {
+                    Debug::log(WARN, "reload_time has unexpected type, using default: -1");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse reload_time: {}", e.what());
+            }
         }
-    }
 
-    if (!isScreenshot && !isVideoBackground && reloadTime > -1) {
-        try {
-            modificationTime = std::filesystem::last_write_time(absolutePath(path, ""));
-        } catch (std::exception& e) { Debug::log(ERR, "{}", e.what()); }
+        crossFadeTime = -1.f;
+        if (props.contains("crossfade_time")) {
+            try {
+                const auto& val = props.at("crossfade_time");
+                if (val.type() == typeid(Hyprlang::FLOAT)) {
+                    crossFadeTime = std::any_cast<Hyprlang::FLOAT>(val);
+                } else if (val.type() == typeid(Hyprlang::INT)) {
+                    crossFadeTime = static_cast<float>(std::any_cast<Hyprlang::INT>(val));
+                } else {
+                    Debug::log(WARN, "crossfade_time has unexpected type, using default: -1");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse crossfade_time: {}", e.what());
+            }
+        }
 
-        plantReloadTimer(); // No reloads for screenshots or videos
+        fallbackPath = "";
+        if (props.contains("fallback_path")) {
+            try {
+                const auto& val = props.at("fallback_path");
+                if (val.type() == typeid(Hyprlang::STRING)) {
+                    fallbackPath = std::any_cast<Hyprlang::STRING>(val);
+                } else {
+                    Debug::log(WARN, "fallback_path has unexpected type, using default: empty");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse fallback_path: {}", e.what());
+            }
+        }
+
+        isScreenshot = path == "screenshot";
+        monitor = pOutput->stringPort;
+        std::string type = "image";
+        if (props.contains("type")) {
+            try {
+                const auto& val = props.at("type");
+                if (val.type() == typeid(Hyprlang::STRING)) {
+                    type = std::any_cast<Hyprlang::STRING>(val);
+                } else {
+                    Debug::log(WARN, "type has unexpected type, using default: image");
+                }
+            } catch (const std::exception& e) {
+                Debug::log(ERR, "Failed to parse type: {}", e.what());
+            }
+        }
+
+        isVideoBackground = false;
+        videoPath = "";
+        resourceID = "";
+        if (type == "video" || path.ends_with(".mp4")) {
+            videoPath = path;
+            Debug::log(LOG, "Detected video background: {}", path);
+            if (!path.empty()) {
+                Debug::log(LOG, "Attempting to start mpvpaper for monitor {} with video {}", monitor, path);
+                bool mpvSuccess = g_pRenderer->startMpvpaper(monitor, path);
+                isVideoBackground = mpvSuccess;
+                if (!mpvSuccess) {
+                    if (!fallbackPath.empty() && !fallbackPath.ends_with(".mp4")) {
+                        Debug::log(LOG, "Video background failed, using fallback: {}", fallbackPath);
+                        resourceID = "background:" + fallbackPath;
+                    } else {
+                        Debug::log(ERR, "Video background failed and no valid fallback path provided, using transparent.");
+                        resourceID = "";
+                    }
+                }
+            }
+        } else {
+            resourceID = isScreenshot ? CScreencopyFrame::getResourceId(pOutput) : (!path.empty() && !path.ends_with(".mp4") ? "background:" + path : "");
+        }
+
+        viewport = pOutput->getViewport();
+        outputPort = pOutput->stringPort;
+        transform = isScreenshot ? wlTransformToHyprutils(invertTransform(pOutput->transform)) : HYPRUTILS_TRANSFORM_NORMAL;
+
+        if (isScreenshot && !isVideoBackground) {
+            if (g_pRenderer->asyncResourceGatherer->gathered) {
+                if (!g_pRenderer->asyncResourceGatherer->getAssetByID(resourceID))
+                    resourceID = "";
+            }
+            if (!g_pHyprlock->getScreencopy()) {
+                Debug::log(ERR, "No screencopy support! path=screenshot won't work. Falling back to transparent.");
+                resourceID = "";
+            }
+        }
+
+        if (!isScreenshot && !isVideoBackground && reloadTime > -1) {
+            try {
+                modificationTime = std::filesystem::last_write_time(absolutePath(path, ""));
+            } catch (std::exception& e) { Debug::log(ERR, "{}", e.what()); }
+            plantReloadTimer();
+        }
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "Exception in CBackground::configure: {}", e.what());
+        isVideoBackground = false;
+        resourceID = "";
     }
 }
 
@@ -86,7 +308,6 @@ void CBackground::reset() {
         reloadTimer->cancel();
         reloadTimer.reset();
     }
-
     if (fade) {
         if (fade->crossFadeTimer) {
             fade->crossFadeTimer->cancel();
@@ -97,32 +318,14 @@ void CBackground::reset() {
 }
 
 void CBackground::renderRect(CHyprColor color) {
-    CBox monbox = {0, 0, viewport.x, viewport.y};
+    CBox monbox = {0, 0, (int)viewport.x, (int)viewport.y};
     g_pRenderer->renderRect(monbox, color, 0);
 }
 
-static void onReloadTimer(WP<CBackground> ref) {
-    if (auto PBG = ref.lock(); PBG) {
-        PBG->onReloadTimerUpdate();
-        PBG->plantReloadTimer();
-    }
-}
-
-static void onCrossFadeTimer(WP<CBackground> ref) {
-    if (auto PBG = ref.lock(); PBG)
-        PBG->onCrossFadeTimerUpdate();
-}
-
-static void onAssetCallback(WP<CBackground> ref) {
-    if (auto PBG = ref.lock(); PBG)
-        PBG->startCrossFadeOrUpdateRender();
-}
-
 bool CBackground::draw(const SRenderData& data) {
     if (isVideoBackground) {
-        // Skip rendering the static background since mpvpaper is handling the video
         Debug::log(LOG, "Skipping static background rendering; using video background via mpvpaper");
-        return false;
+        return false; // mpvpaper handles rendering
     }
 
     if (resourceID.empty()) {
@@ -152,15 +355,13 @@ bool CBackground::draw(const SRenderData& data) {
         if (firstRender)
             firstRender = false;
 
-        // make it brah
         Vector2D size = asset->texture.m_vSize;
         if (transform % 2 == 1 && isScreenshot) {
             size.x = asset->texture.m_vSize.y;
             size.y = asset->texture.m_vSize.x;
         }
 
-        CBox  texbox = {{}, size};
-
+        CBox texbox = {{}, size};
         float scaleX = viewport.x / size.x;
         float scaleY = viewport.y / size.y;
 
@@ -174,7 +375,7 @@ bool CBackground::draw(const SRenderData& data) {
         texbox.round();
 
         if (!blurredFB.isAllocated())
-            blurredFB.alloc(viewport.x, viewport.y); // TODO 10 bit
+            blurredFB.alloc((int)viewport.x, (int)viewport.y);
 
         blurredFB.bind();
 
@@ -187,12 +388,12 @@ bool CBackground::draw(const SRenderData& data) {
 
         if (blurPasses > 0)
             g_pRenderer->blurFB(blurredFB,
-                                CRenderer::SBlurParams{.size              = blurSize,
-                                                       .passes            = blurPasses,
-                                                       .noise             = noise,
-                                                       .contrast          = contrast,
-                                                       .brightness        = brightness,
-                                                       .vibrancy          = vibrancy,
+                                CRenderer::SBlurParams{.size = blurSize,
+                                                       .passes = blurPasses,
+                                                       .noise = noise,
+                                                       .contrast = contrast,
+                                                       .brightness = brightness,
+                                                       .vibrancy = vibrancy,
                                                        .vibrancy_darkness = vibrancy_darkness});
         glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
     }
@@ -200,7 +401,6 @@ bool CBackground::draw(const SRenderData& data) {
     CTexture* tex = blurredFB.isAllocated() ? &blurredFB.m_cTex : &asset->texture;
 
     CBox      texbox = {{}, tex->m_vSize};
-
     Vector2D  size   = tex->m_vSize;
     float     scaleX = viewport.x / tex->m_vSize.x;
     float     scaleY = viewport.y / tex->m_vSize.y;
@@ -215,52 +415,31 @@ bool CBackground::draw(const SRenderData& data) {
     texbox.round();
     g_pRenderer->renderTexture(texbox, *tex, data.opacity, 0, HYPRUTILS_TRANSFORM_FLIPPED_180);
 
-    return fade || data.opacity < 1.0; // actively render during fading
+    return fade || data.opacity < 1.0;
 }
+
 void CBackground::plantReloadTimer() {
     if (reloadTime == 0)
-        reloadTimer = g_pHyprlock->addTimer(std::chrono::hours(1), [REF = m_self](auto, auto) { onReloadTimer(REF); }, nullptr, true);
-    else if (reloadTime > 0)
-        reloadTimer = g_pHyprlock->addTimer(std::chrono::seconds(reloadTime), [REF = m_self](auto, auto) { onReloadTimer(REF); }, nullptr, true);
-}
-
-void CBackground::onCrossFadeTimerUpdate() {
-    // Animation done: Unload previous asset, deinitialize the fade and pass the asset
-    if (fade) {
-        fade->crossFadeTimer.reset();
-        fade.reset();
-    }
-
-    if (blurPasses <= 0 && !isScreenshot)
-        blurredFB.release();
-
-    asset             = pendingAsset;
-    resourceID        = pendingResourceID;
-    pendingResourceID = "";
-    pendingAsset      = nullptr;
-    firstRender       = true;
-
-    g_pHyprlock->renderOutput(outputPort);
+        reloadTimer = g_pHyprlock->addTimer(std::chrono::hours(1),
+            [REF = m_self](std::shared_ptr<CTimer>, void*) { REF.lock()->onReloadTimerUpdate(); }, nullptr, true);
+    else if (reloadTime > -1)
+        reloadTimer = g_pHyprlock->addTimer(std::chrono::seconds(reloadTime),
+            [REF = m_self](std::shared_ptr<CTimer>, void*) { REF.lock()->onReloadTimerUpdate(); }, nullptr, true);
 }
 
 void CBackground::onReloadTimerUpdate() {
     const std::string OLDPATH = path;
 
-    // Path parsing and early returns
     if (!reloadCommand.empty()) {
         path = g_pHyprlock->spawnSync(reloadCommand);
-
         if (path.ends_with('\n'))
             path.pop_back();
-
         if (path.starts_with("file://"))
             path = path.substr(7);
-
         if (path.empty())
             return;
     }
 
-    // Skip reload for video backgrounds
     if (isVideoBackground)
         return;
 
@@ -268,7 +447,6 @@ void CBackground::onReloadTimerUpdate() {
         const auto MTIME = std::filesystem::last_write_time(absolutePath(path, ""));
         if (OLDPATH == path && MTIME == modificationTime)
             return;
-
         modificationTime = MTIME;
     } catch (std::exception& e) {
         path = OLDPATH;
@@ -279,17 +457,33 @@ void CBackground::onReloadTimerUpdate() {
     if (!pendingResourceID.empty())
         return;
 
-    // Issue the next request
-    request.id        = std::string{"background:"} + path + ",time:" + std::to_string((uint64_t)modificationTime.time_since_epoch().count());
+    request.id = std::string{"background:"} + path + ",time:" + std::to_string((uint64_t)modificationTime.time_since_epoch().count());
     pendingResourceID = request.id;
-    request.asset     = path;
-    request.type      = CAsyncResourceGatherer::eTargetType::TARGET_IMAGE;
-
-    request.callback = [REF = m_self]() { onAssetCallback(REF); };
+    request.asset = path;
+    request.type = CAsyncResourceGatherer::eTargetType::TARGET_IMAGE;
 
+    request.callback = [REF = m_self]() { REF.lock()->startCrossFadeOrUpdateRender(); };
     g_pRenderer->asyncResourceGatherer->requestAsyncAssetPreload(request);
 }
 
+void CBackground::onCrossFadeTimerUpdate() {
+    if (fade) {
+        fade->crossFadeTimer.reset();
+        fade.reset();
+    }
+
+    if (blurPasses <= 0 && !isScreenshot)
+        blurredFB.release();
+
+    asset = pendingAsset;
+    resourceID = pendingResourceID;
+    pendingResourceID = "";
+    pendingAsset = nullptr;
+    firstRender = true;
+
+    g_pHyprlock->renderOutput(outputPort);
+}
+
 void CBackground::startCrossFadeOrUpdateRender() {
     auto newAsset = g_pRenderer->asyncResourceGatherer->getAssetByID(pendingResourceID);
     if (newAsset) {
@@ -299,27 +493,27 @@ void CBackground::startCrossFadeOrUpdateRender() {
         } else if (resourceID != pendingResourceID) {
             pendingAsset = newAsset;
             if (crossFadeTime > 0) {
-                // Start a fade
                 if (!fade)
-                    fade = makeUnique<SFade>(std::chrono::system_clock::now(), 0, nullptr);
+                    fade = makeUnique<SFade>();
                 else {
-                    // Maybe we were already fading so reset it just in case, but shouldn't be happening.
                     if (fade->crossFadeTimer) {
                         fade->crossFadeTimer->cancel();
                         fade->crossFadeTimer.reset();
                     }
                 }
                 fade->start = std::chrono::system_clock::now();
-                fade->a     = 0;
+                fade->a = 0;
                 fade->crossFadeTimer =
-                    g_pHyprlock->addTimer(std::chrono::milliseconds((int)(1000.0 * crossFadeTime)), [REF = m_self](auto, auto) { onCrossFadeTimer(REF); }, nullptr);
+                    g_pHyprlock->addTimer(std::chrono::milliseconds((int)(1000.0 * crossFadeTime)),
+                        [REF = m_self](std::shared_ptr<CTimer>, void*) { REF.lock()->onCrossFadeTimerUpdate(); }, nullptr, true);
             } else {
                 onCrossFadeTimerUpdate();
             }
         }
     } else if (!pendingResourceID.empty()) {
         Debug::log(WARN, "Asset {} not available after the asyncResourceGatherer's callback!", pendingResourceID);
-        g_pHyprlock->addTimer(std::chrono::milliseconds(100), [REF = m_self](auto, auto) { onAssetCallback(REF); }, nullptr);
+        g_pHyprlock->addTimer(std::chrono::milliseconds(100),
+            [REF = m_self](std::shared_ptr<CTimer>, void*) { REF.lock()->startCrossFadeOrUpdateRender(); }, nullptr, true);
     }
 
     g_pHyprlock->renderOutput(outputPort);
diff --git a/src/renderer/widgets/Background.hpp b/src/renderer/widgets/Background.hpp
index e42b596d..015b8ae8 100644
--- a/src/renderer/widgets/Background.hpp
+++ b/src/renderer/widgets/Background.hpp
@@ -29,8 +29,9 @@ class CBackground : public IWidget {
 
     void         registerSelf(const SP<CBackground>& self);
 
-    virtual void configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput);
-    virtual bool draw(const SRenderData& data);
+    virtual void configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput) override;
+    virtual bool draw(const SRenderData& data) override;
+    virtual std::string type() const override; // Added for layered rendering
 
     void         reset(); // Unload assets, remove timers, etc.
 
@@ -41,9 +42,11 @@ class CBackground : public IWidget {
     void         plantReloadTimer();
     void         startCrossFadeOrUpdateRender();
 
-    // New members for video background support
+    // Members for video background support
     bool         isVideoBackground = false;
     std::string  videoPath;
+    std::string  monitor; // Store monitor name for mpvpaper
+    std::string  fallbackPath; // Added for fallback image if video fails
 
   private:
     WP<CBackground> m_self;
diff --git a/src/renderer/widgets/IWidget.hpp b/src/renderer/widgets/IWidget.hpp
index f13f6c38..921870f3 100644
--- a/src/renderer/widgets/IWidget.hpp
+++ b/src/renderer/widgets/IWidget.hpp
@@ -17,7 +17,8 @@ class IWidget {
     virtual ~IWidget() = default;
 
     virtual void    configure(const std::unordered_map<std::string, std::any>& prop, const SP<COutput>& pOutput) = 0;
-    virtual bool    draw(const SRenderData& data)                                                                = 0;
+    virtual bool    draw(const SRenderData& data) = 0;
+    virtual std::string type() const = 0; // Added for layered rendering
 
     static Vector2D posFromHVAlign(const Vector2D& viewport, const Vector2D& size, const Vector2D& offset, const std::string& halign, const std::string& valign,
                                    const double& ang = 0);
@@ -33,4 +34,4 @@ class IWidget {
     };
 
     static SFormatResult formatString(std::string in);
-};
+};
\ No newline at end of file
diff --git a/src/renderer/widgets/Image.cpp b/src/renderer/widgets/Image.cpp
index b9977dc1..4d43d385 100644
--- a/src/renderer/widgets/Image.cpp
+++ b/src/renderer/widgets/Image.cpp
@@ -15,6 +15,10 @@ void CImage::registerSelf(const SP<CImage>& self) {
     m_self = self;
 }
 
+std::string CImage::type() const {
+    return "image";
+}
+
 static void onTimer(WP<CImage> ref) {
     if (auto PIMAGE = ref.lock(); PIMAGE) {
         PIMAGE->onTimerUpdate();
@@ -32,13 +36,10 @@ void CImage::onTimerUpdate() {
 
     if (!reloadCommand.empty()) {
         path = g_pHyprlock->spawnSync(reloadCommand);
-
         if (path.ends_with('\n'))
             path.pop_back();
-
         if (path.starts_with("file://"))
             path = path.substr(7);
-
         if (path.empty())
             return;
     }
@@ -47,7 +48,6 @@ void CImage::onTimerUpdate() {
         const auto MTIME = std::filesystem::last_write_time(absolutePath(path, ""));
         if (OLDPATH == path && MTIME == modificationTime)
             return;
-
         modificationTime = MTIME;
     } catch (std::exception& e) {
         path = OLDPATH;
@@ -58,17 +58,16 @@ void CImage::onTimerUpdate() {
     if (!pendingResourceID.empty())
         return;
 
-    request.id        = std::string{"image:"} + path + ",time:" + std::to_string((uint64_t)modificationTime.time_since_epoch().count());
+    request.id = std::string{"image:"} + path + ",time:" + std::to_string((uint64_t)modificationTime.time_since_epoch().count());
     pendingResourceID = request.id;
-    request.asset     = path;
-    request.type      = CAsyncResourceGatherer::eTargetType::TARGET_IMAGE;
-    request.callback  = [REF = m_self]() { onAssetCallback(REF); };
+    request.asset = path;
+    request.type = CAsyncResourceGatherer::eTargetType::TARGET_IMAGE;
+    request.callback = [REF = m_self]() { onAssetCallback(REF); };
 
     g_pRenderer->asyncResourceGatherer->requestAsyncAssetPreload(request);
 }
 
 void CImage::plantTimer() {
-
     if (reloadTime == 0) {
         imageTimer = g_pHyprlock->addTimer(std::chrono::hours(1), [REF = m_self](auto, auto) { onTimer(REF); }, nullptr, true);
     } else if (reloadTime > 0)
@@ -83,32 +82,30 @@ void CImage::configure(const std::unordered_map<std::string, std::any>& props, c
     shadow.configure(m_self.lock(), props, viewport);
 
     try {
-        size     = std::any_cast<Hyprlang::INT>(props.at("size"));
+        size = std::any_cast<Hyprlang::INT>(props.at("size"));
         rounding = std::any_cast<Hyprlang::INT>(props.at("rounding"));
-        border   = std::any_cast<Hyprlang::INT>(props.at("border_size"));
-        color    = *CGradientValueData::fromAnyPv(props.at("border_color"));
-        pos      = CLayoutValueData::fromAnyPv(props.at("position"))->getAbsolute(viewport);
-        halign   = std::any_cast<Hyprlang::STRING>(props.at("halign"));
-        valign   = std::any_cast<Hyprlang::STRING>(props.at("valign"));
-        angle    = std::any_cast<Hyprlang::FLOAT>(props.at("rotate"));
-
-        path          = std::any_cast<Hyprlang::STRING>(props.at("path"));
-        reloadTime    = std::any_cast<Hyprlang::INT>(props.at("reload_time"));
+        border = std::any_cast<Hyprlang::INT>(props.at("border_size"));
+        color = *CGradientValueData::fromAnyPv(props.at("border_color"));
+        pos = CLayoutValueData::fromAnyPv(props.at("position"))->getAbsolute(viewport);
+        halign = std::any_cast<Hyprlang::STRING>(props.at("halign"));
+        valign = std::any_cast<Hyprlang::STRING>(props.at("valign"));
+        angle = std::any_cast<Hyprlang::FLOAT>(props.at("rotate"));
+        path = std::any_cast<Hyprlang::STRING>(props.at("path"));
+        reloadTime = std::any_cast<Hyprlang::INT>(props.at("reload_time"));
         reloadCommand = std::any_cast<Hyprlang::STRING>(props.at("reload_cmd"));
     } catch (const std::bad_any_cast& e) {
-        RASSERT(false, "Failed to construct CImage: {}", e.what()); //
+        RASSERT(false, "Failed to construct CImage: {}", e.what());
     } catch (const std::out_of_range& e) {
-        RASSERT(false, "Missing propperty for CImage: {}", e.what()); //
+        RASSERT(false, "Missing propperty for CImage: {}", e.what());
     }
 
     resourceID = "image:" + path;
-    angle      = angle * M_PI / 180.0;
+    angle = angle * M_PI / 180.0;
 
     if (reloadTime > -1) {
         try {
             modificationTime = std::filesystem::last_write_time(absolutePath(path, ""));
         } catch (std::exception& e) { Debug::log(ERR, "{}", e.what()); }
-
         plantTimer();
     }
 }
@@ -118,22 +115,17 @@ void CImage::reset() {
         imageTimer->cancel();
         imageTimer.reset();
     }
-
     if (g_pHyprlock->m_bTerminate)
         return;
-
     imageFB.release();
-
-    if (asset && reloadTime > -1) // Don't unload asset if it's a static image
+    if (asset && reloadTime > -1)
         g_pRenderer->asyncResourceGatherer->unloadAsset(asset);
-
-    asset             = nullptr;
+    asset = nullptr;
     pendingResourceID = "";
-    resourceID        = "";
+    resourceID = "";
 }
 
 bool CImage::draw(const SRenderData& data) {
-
     if (resourceID.empty())
         return false;
 
@@ -150,27 +142,22 @@ bool CImage::draw(const SRenderData& data) {
     }
 
     if (!imageFB.isAllocated()) {
-
-        const Vector2D IMAGEPOS  = {border, border};
+        const Vector2D IMAGEPOS = {border, border};
         const Vector2D BORDERPOS = {0.0, 0.0};
-        const Vector2D TEXSIZE   = asset->texture.m_vSize;
-        const float    SCALEX    = size / TEXSIZE.x;
-        const float    SCALEY    = size / TEXSIZE.y;
+        const Vector2D TEXSIZE = asset->texture.m_vSize;
+        const float SCALEX = size / TEXSIZE.x;
+        const float SCALEY = size / TEXSIZE.y;
 
-        // image with borders offset, with extra pixel for anti-aliasing when rotated
         CBox texbox = {angle == 0 ? IMAGEPOS : IMAGEPOS + Vector2D{1.0, 1.0}, TEXSIZE};
-
         texbox.w *= std::max(SCALEX, SCALEY);
         texbox.h *= std::max(SCALEX, SCALEY);
 
-        // plus borders if any
         CBox borderBox = {angle == 0 ? BORDERPOS : BORDERPOS + Vector2D{1.0, 1.0}, texbox.size() + IMAGEPOS * 2.0};
-
         borderBox.round();
 
-        const Vector2D FBSIZE      = angle == 0 ? borderBox.size() : borderBox.size() + Vector2D{2.0, 2.0};
-        const int      ROUND       = roundingForBox(texbox, rounding);
-        const int      BORDERROUND = roundingForBorderBox(borderBox, rounding, border);
+        const Vector2D FBSIZE = angle == 0 ? borderBox.size() : borderBox.size() + Vector2D{2.0, 2.0};
+        const int ROUND = roundingForBox(texbox, rounding);
+        const int BORDERROUND = roundingForBorderBox(borderBox, rounding, border);
 
         imageFB.alloc(FBSIZE.x, FBSIZE.y, true);
         g_pRenderer->pushFb(imageFB.m_iFb);
@@ -185,8 +172,8 @@ bool CImage::draw(const SRenderData& data) {
         g_pRenderer->popFb();
     }
 
-    CTexture* tex    = &imageFB.m_cTex;
-    CBox      texbox = {{}, tex->m_vSize};
+    CTexture* tex = &imageFB.m_cTex;
+    CBox texbox = {{}, tex->m_vSize};
 
     if (firstRender) {
         firstRender = false;
@@ -196,7 +183,6 @@ bool CImage::draw(const SRenderData& data) {
     shadow.draw(data);
 
     const auto TEXPOS = posFromHVAlign(viewport, tex->m_vSize, pos, halign, valign, angle);
-
     texbox.x = TEXPOS.x;
     texbox.y = TEXPOS.y;
 
@@ -215,9 +201,8 @@ void CImage::renderUpdate() {
         } else if (resourceID != pendingResourceID) {
             g_pRenderer->asyncResourceGatherer->unloadAsset(asset);
             imageFB.release();
-
-            asset       = newAsset;
-            resourceID  = pendingResourceID;
+            asset = newAsset;
+            resourceID = pendingResourceID;
             firstRender = true;
         }
         pendingResourceID = "";
@@ -231,4 +216,4 @@ void CImage::renderUpdate() {
     }
 
     g_pHyprlock->renderOutput(output->stringPort);
-}
+}
\ No newline at end of file
diff --git a/src/renderer/widgets/Image.hpp b/src/renderer/widgets/Image.hpp
index 24e8a9f5..ae07f3cc 100644
--- a/src/renderer/widgets/Image.hpp
+++ b/src/renderer/widgets/Image.hpp
@@ -20,43 +20,39 @@ class CImage : public IWidget {
     CImage() = default;
     ~CImage();
 
-    void         registerSelf(const SP<CImage>& self);
+    void registerSelf(const SP<CImage>& self);
 
-    virtual void configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput);
-    virtual bool draw(const SRenderData& data);
+    virtual void configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput) override;
+    virtual bool draw(const SRenderData& data) override;
+    virtual std::string type() const override; // Added for layered rendering
 
-    void         reset();
-
-    void         renderUpdate();
-    void         onTimerUpdate();
-    void         plantTimer();
+    void reset();
+    void renderUpdate();
+    void onTimerUpdate();
+    void plantTimer();
 
   private:
-    WP<CImage>                              m_self;
-
-    CFramebuffer                            imageFB;
-
-    int                                     size;
-    int                                     rounding;
-    double                                  border;
-    double                                  angle;
-    CGradientValueData                      color;
-    Vector2D                                pos;
-
-    std::string                             halign, valign, path;
-
-    bool                                    firstRender = true;
-
-    int                                     reloadTime;
-    std::string                             reloadCommand;
-    std::filesystem::file_time_type         modificationTime;
-    std::shared_ptr<CTimer>                 imageTimer;
+    WP<CImage> m_self;
+
+    CFramebuffer imageFB;
+
+    int size;
+    int rounding;
+    double border;
+    double angle;
+    CGradientValueData color;
+    Vector2D pos;
+    std::string halign, valign, path;
+    bool firstRender = true;
+    int reloadTime;
+    std::string reloadCommand;
+    std::filesystem::file_time_type modificationTime;
+    std::shared_ptr<CTimer> imageTimer;
     CAsyncResourceGatherer::SPreloadRequest request;
-
-    Vector2D                                viewport;
-    std::string                             resourceID;
-    std::string                             pendingResourceID; // if reloading image
-    SPreloadedAsset*                        asset  = nullptr;
-    COutput*                                output = nullptr;
-    CShadowable                             shadow;
-};
+    Vector2D viewport;
+    std::string resourceID;
+    std::string pendingResourceID; // if reloading image
+    SPreloadedAsset* asset = nullptr;
+    COutput* output = nullptr;
+    CShadowable shadow;
+};
\ No newline at end of file
diff --git a/src/renderer/widgets/Label.cpp b/src/renderer/widgets/Label.cpp
index aa57aba3..cf7f1e1c 100644
--- a/src/renderer/widgets/Label.cpp
+++ b/src/renderer/widgets/Label.cpp
@@ -15,6 +15,10 @@ void CLabel::registerSelf(const SP<CLabel>& self) {
     m_self = self;
 }
 
+std::string CLabel::type() const {
+    return "label";
+}
+
 static void onTimer(WP<CLabel> ref) {
     if (auto PLABEL = ref.lock(); PLABEL) {
         // update label
@@ -57,7 +61,6 @@ void CLabel::onTimerUpdate() {
 }
 
 void CLabel::plantTimer() {
-
     if (label.updateEveryMs != 0)
         labelTimer = g_pHyprlock->addTimer(std::chrono::milliseconds((int)label.updateEveryMs), [REF = m_self](auto, auto) { onTimer(REF); }, this, label.allowForceUpdate);
     else if (label.updateEveryMs == 0 && label.allowForceUpdate)
@@ -171,4 +174,4 @@ void CLabel::renderUpdate() {
     }
 
     g_pHyprlock->renderOutput(outputStringPort);
-}
+}
\ No newline at end of file
diff --git a/src/renderer/widgets/Label.hpp b/src/renderer/widgets/Label.hpp
index b9d489a8..d8389dc8 100644
--- a/src/renderer/widgets/Label.hpp
+++ b/src/renderer/widgets/Label.hpp
@@ -17,40 +17,38 @@ class CLabel : public IWidget {
     CLabel() = default;
     ~CLabel();
 
-    void         registerSelf(const SP<CLabel>& self);
+    void registerSelf(const SP<CLabel>& self);
 
-    virtual void configure(const std::unordered_map<std::string, std::any>& prop, const SP<COutput>& pOutput);
-    virtual bool draw(const SRenderData& data);
+    virtual void configure(const std::unordered_map<std::string, std::any>& prop, const SP<COutput>& pOutput) override;
+    virtual bool draw(const SRenderData& data) override;
+    virtual std::string type() const override; // Added for layered rendering
 
-    void         reset();
-
-    void         renderUpdate();
-    void         onTimerUpdate();
-    void         plantTimer();
+    void reset();
+    void renderUpdate();
+    void onTimerUpdate();
+    void plantTimer();
 
   private:
-    WP<CLabel>                              m_self;
-
-    std::string                             getUniqueResourceId();
+    WP<CLabel> m_self;
 
-    std::string                             labelPreFormat;
-    IWidget::SFormatResult                  label;
+    std::string getUniqueResourceId();
 
-    Vector2D                                viewport;
-    Vector2D                                pos;
-    Vector2D                                configPos;
-    double                                  angle;
-    std::string                             resourceID;
-    std::string                             pendingResourceID; // if dynamic label
-    std::string                             halign, valign;
-    SPreloadedAsset*                        asset = nullptr;
+    std::string labelPreFormat;
+    IWidget::SFormatResult label;
 
-    std::string                             outputStringPort;
+    Vector2D viewport;
+    Vector2D pos;
+    Vector2D configPos;
+    double angle;
+    std::string resourceID;
+    std::string pendingResourceID; // if dynamic label
+    std::string halign, valign;
+    SPreloadedAsset* asset = nullptr;
+    std::string outputStringPort;
 
     CAsyncResourceGatherer::SPreloadRequest request;
+    std::shared_ptr<CTimer> labelTimer = nullptr;
 
-    std::shared_ptr<CTimer>                 labelTimer = nullptr;
-
-    CShadowable                             shadow;
-    bool                                    updateShadow = true;
-};
+    CShadowable shadow;
+    bool updateShadow = true;
+};
\ No newline at end of file
diff --git a/src/renderer/widgets/PasswordInputField.cpp b/src/renderer/widgets/PasswordInputField.cpp
index b27a0eed..1dd8f653 100644
--- a/src/renderer/widgets/PasswordInputField.cpp
+++ b/src/renderer/widgets/PasswordInputField.cpp
@@ -23,6 +23,10 @@ void CPasswordInputField::registerSelf(const SP<CPasswordInputField>& self) {
     m_self = self;
 }
 
+std::string CPasswordInputField::type() const {
+    return "input-field";
+}
+
 void CPasswordInputField::configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput) {
     reset();
 
@@ -472,4 +476,4 @@ void CPasswordInputField::updateColors() {
         *colorState.inner = innerTarget;
 
     colorState.font = fontTarget;
-}
+}
\ No newline at end of file
diff --git a/src/renderer/widgets/PasswordInputField.hpp b/src/renderer/widgets/PasswordInputField.hpp
index 179680d6..44e36373 100644
--- a/src/renderer/widgets/PasswordInputField.hpp
+++ b/src/renderer/widgets/PasswordInputField.hpp
@@ -19,105 +19,100 @@ class CPasswordInputField : public IWidget {
     CPasswordInputField() = default;
     virtual ~CPasswordInputField();
 
-    void         registerSelf(const SP<CPasswordInputField>& self);
+    void registerSelf(const SP<CPasswordInputField>& self);
 
-    virtual void configure(const std::unordered_map<std::string, std::any>& prop, const SP<COutput>& pOutput);
-    virtual bool draw(const SRenderData& data);
+    virtual void configure(const std::unordered_map<std::string, std::any>& prop, const SP<COutput>& pOutput) override;
+    virtual bool draw(const SRenderData& data) override;
+    virtual std::string type() const override; // Added for layered rendering
 
-    void         reset();
-    void         onFadeOutTimer();
+    void reset();
+    void onFadeOutTimer();
 
   private:
     WP<CPasswordInputField> m_self;
 
-    void                    updateDots();
-    void                    updateFade();
-    void                    updatePlaceholder();
-    void                    updateWidth();
-    void                    updateHiddenInputState();
-    void                    updateInputState();
-    void                    updateColors();
+    void updateDots();
+    void updateFade();
+    void updatePlaceholder();
+    void updateWidth();
+    void updateHiddenInputState();
+    void updateInputState();
+    void updateColors();
 
-    bool                    firstRender  = true;
-    bool                    redrawShadow = false;
-    bool                    checkWaiting = false;
-    bool                    displayFail  = false;
+    bool firstRender = true;
+    bool redrawShadow = false;
+    bool checkWaiting = false;
+    bool displayFail = false;
 
-    size_t                  passwordLength = 0;
+    size_t passwordLength = 0;
 
-    PHLANIMVAR<Vector2D>    size;
-    Vector2D                pos;
-    Vector2D                viewport;
-    Vector2D                configPos;
-    Vector2D                configSize;
+    PHLANIMVAR<Vector2D> size;
+    Vector2D pos;
+    Vector2D viewport;
+    Vector2D configPos;
+    Vector2D configSize;
 
-    std::string             halign, valign, configFailText, outputStringPort, configPlaceholderText, fontFamily;
-    uint64_t                configFailTimeoutMs = 2000;
+    std::string halign, valign, configFailText, outputStringPort, configPlaceholderText, fontFamily;
+    uint64_t configFailTimeoutMs = 2000;
 
-    int                     outThick, rounding;
+    int outThick, rounding;
 
     struct {
         PHLANIMVAR<float> currentAmount;
-        bool              center     = false;
-        float             size       = 0;
-        float             spacing    = 0;
-        int               rounding   = 0;
-        std::string       textFormat = "";
-        std::string       textResourceID;
-        SPreloadedAsset*  textAsset = nullptr;
+        bool center = false;
+        float size = 0;
+        float spacing = 0;
+        int rounding = 0;
+        std::string textFormat = "";
+        std::string textResourceID;
+        SPreloadedAsset* textAsset = nullptr;
     } dots;
 
     struct {
-        PHLANIMVAR<float>       a;
-        bool                    appearing    = true;
+        PHLANIMVAR<float> a;
+        bool appearing = true;
         std::shared_ptr<CTimer> fadeOutTimer = nullptr;
-        bool                    allowFadeOut = false;
+        bool allowFadeOut = false;
     } fade;
 
     struct {
-        std::string              resourceID = "";
-        SPreloadedAsset*         asset      = nullptr;
-
-        std::string              currentText    = "";
-        size_t                   failedAttempts = 0;
-
+        std::string resourceID = "";
+        SPreloadedAsset* asset = nullptr;
+        std::string currentText = "";
+        size_t failedAttempts = 0;
         std::vector<std::string> registeredResourceIDs;
     } placeholder;
 
     struct {
         CHyprColor lastColor;
-        int        lastQuadrant       = 0;
-        int        lastPasswordLength = 0;
-        bool       enabled            = false;
+        int lastQuadrant = 0;
+        int lastPasswordLength = 0;
+        bool enabled = false;
     } hiddenInputState;
 
     struct {
         CGradientValueData* outer = nullptr;
-        CHyprColor          inner;
-        CHyprColor          font;
-        CGradientValueData* fail  = nullptr;
+        CHyprColor inner;
+        CHyprColor font;
+        CGradientValueData* fail = nullptr;
         CGradientValueData* check = nullptr;
-        CGradientValueData* caps  = nullptr;
-        CGradientValueData* num   = nullptr;
-        CGradientValueData* both  = nullptr;
-
-        CHyprColor          hiddenBase;
-
-        int                 transitionMs = 0;
-        bool                invertNum    = false;
-        bool                swapFont     = false;
+        CGradientValueData* caps = nullptr;
+        CGradientValueData* num = nullptr;
+        CGradientValueData* both = nullptr;
+        CHyprColor hiddenBase;
+        int transitionMs = 0;
+        bool invertNum = false;
+        bool swapFont = false;
     } colorConfig;
 
     struct {
         PHLANIMVAR<CGradientValueData> outer;
-        PHLANIMVAR<CHyprColor>         inner;
-        // Font color is only chaned, when `swap_font_color` is set to true and no border is present.
-        // It is not animated, because that does not look good and we would need to rerender the text for each frame.
+        PHLANIMVAR<CHyprColor> inner;
         CHyprColor font;
     } colorState;
 
-    bool        fadeOnEmpty;
-    uint64_t    fadeTimeoutMs;
+    bool fadeOnEmpty;
+    uint64_t fadeTimeoutMs;
 
     CShadowable shadow;
-};
+};
\ No newline at end of file
diff --git a/src/renderer/widgets/Shape.cpp b/src/renderer/widgets/Shape.cpp
index 6499245d..02399042 100644
--- a/src/renderer/widgets/Shape.cpp
+++ b/src/renderer/widgets/Shape.cpp
@@ -1,102 +1,235 @@
 #include "Shape.hpp"
 #include "../Renderer.hpp"
 #include "../../config/ConfigDataValues.hpp"
-#include <cmath>
+#include "../../helpers/Log.hpp"
 #include <hyprlang.hpp>
+#include <GLES3/gl32.h>
+#include <cmath>
+#include <optional> // Added for SBlurParams::std::optional<CHyprColor>
 
 void CShape::registerSelf(const SP<CShape>& self) {
     m_self = self;
 }
 
+std::string CShape::type() const {
+    return "shape";
+}
+
 void CShape::configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput) {
     viewport = pOutput->getViewport();
 
-    shadow.configure(m_self.lock(), props, viewport);
-
     try {
-        size       = CLayoutValueData::fromAnyPv(props.at("size"))->getAbsolute(viewport);
-        rounding   = std::any_cast<Hyprlang::INT>(props.at("rounding"));
-        border     = std::any_cast<Hyprlang::INT>(props.at("border_size"));
-        color      = std::any_cast<Hyprlang::INT>(props.at("color"));
-        borderGrad = *CGradientValueData::fromAnyPv(props.at("border_color"));
-        pos        = CLayoutValueData::fromAnyPv(props.at("position"))->getAbsolute(viewport);
-        halign     = std::any_cast<Hyprlang::STRING>(props.at("halign"));
-        valign     = std::any_cast<Hyprlang::STRING>(props.at("valign"));
-        angle      = std::any_cast<Hyprlang::FLOAT>(props.at("rotate"));
-        xray       = std::any_cast<Hyprlang::INT>(props.at("xray"));
-    } catch (const std::bad_any_cast& e) {
-        RASSERT(false, "Failed to construct CShape: {}", e.what()); //
-    } catch (const std::out_of_range& e) {
-        RASSERT(false, "Missing property for CShape: {}", e.what()); //
-    }
-
-    angle = angle * M_PI / 180.0;
-
-    const Vector2D VBORDER  = {border, border};
-    const Vector2D REALSIZE = size + VBORDER * 2.0;
-    const Vector2D OFFSET   = angle == 0 ? Vector2D{0.0, 0.0} : Vector2D{1.0, 1.0};
+        // Parse position
+        pos = {0, 0};
+        if (props.contains("position")) {
+            auto val = props.at("position");
+            if (val.type() == typeid(Hyprlang::VEC2)) {
+                auto vec = std::any_cast<Hyprlang::VEC2>(val);
+                pos = {static_cast<double>(vec.x), static_cast<double>(vec.y)};
+            } else {
+                Debug::log(WARN, "Shape position has unexpected type, defaulting to (0, 0)");
+            }
+        }
 
-    pos = posFromHVAlign(viewport, xray ? size : REALSIZE + OFFSET * 2.0, pos, halign, valign, xray ? 0 : angle);
+        // Parse size
+        size = {100, 100};
+        if (props.contains("size")) {
+            auto val = props.at("size");
+            if (val.type() == typeid(Hyprlang::VEC2)) {
+                auto vec = std::any_cast<Hyprlang::VEC2>(val);
+                size = {static_cast<double>(vec.x), static_cast<double>(vec.y)};
+            } else {
+                Debug::log(WARN, "Shape size has unexpected type, defaulting to 100x100");
+            }
+        }
 
-    if (xray) {
-        shapeBox  = {pos, size};
-        borderBox = {pos - VBORDER, REALSIZE};
-    } else {
-        shapeBox  = {OFFSET + VBORDER, size};
-        borderBox = {OFFSET, REALSIZE};
-    }
-}
+        // Parse color
+        color = CHyprColor(1.0, 1.0, 1.0, 0.5); // Semi-transparent white default
+        if (props.contains("color")) {
+            auto colorVal = props.at("color");
+            if (colorVal.type() == typeid(Hyprlang::STRING)) {
+                std::string colorStr = std::any_cast<Hyprlang::STRING>(colorVal);
+                if (colorStr.starts_with("0x") || colorStr.starts_with("#"))
+                    colorStr = colorStr.substr(2);
+                uint64_t colorValue = std::stoull(colorStr, nullptr, 16);
+                color = CHyprColor(colorValue);
+            } else if (colorVal.type() == typeid(Hyprlang::INT)) {
+                uint64_t colorValue = std::any_cast<Hyprlang::INT>(colorVal);
+                color = CHyprColor(colorValue);
+            } else {
+                Debug::log(WARN, "Shape color has unexpected type, defaulting to semi-transparent white");
+            }
+        }
 
-bool CShape::draw(const SRenderData& data) {
+        // Parse shape type
+        shapeType = "rectangle";
+        if (props.contains("shape")) {
+            auto val = props.at("shape");
+            if (val.type() == typeid(Hyprlang::STRING)) {
+                shapeType = std::any_cast<Hyprlang::STRING>(val);
+            } else {
+                Debug::log(WARN, "Shape type has unexpected type, defaulting to rectangle");
+            }
+        }
 
-    if (firstRender) {
-        firstRender = false;
-        shadow.markShadowDirty();
-    }
+        // Parse blur
+        blurEnabled = false;
+        blurParams = {.size = 0, .passes = 0}; // Initialize local blurParams struct
+        if (props.contains("blur")) {
+            auto val = props.at("blur");
+            if (val.type() == typeid(Hyprlang::INT) && std::any_cast<Hyprlang::INT>(val) > 0) {
+                blurEnabled = true;
+                blurParams.size = std::any_cast<Hyprlang::INT>(val);
+                blurParams.passes = 3; // Default passes
+            } else if (val.type() == typeid(Hyprlang::FLOAT) && std::any_cast<Hyprlang::FLOAT>(val) > 0) {
+                blurEnabled = true;
+                blurParams.size = static_cast<int>(std::any_cast<Hyprlang::FLOAT>(val));
+                blurParams.passes = 3;
+            } else {
+                Debug::log(WARN, "Shape blur has unexpected type or value, disabling blur");
+            }
+        }
 
-    shadow.draw(data);
+        // Parse zindex
+        zindex = 10; // Default: above background, below input-field
+        if (props.contains("zindex")) {
+            auto val = props.at("zindex");
+            if (val.type() == typeid(Hyprlang::INT)) {
+                zindex = std::any_cast<Hyprlang::INT>(val);
+            } else {
+                Debug::log(WARN, "Shape zindex has unexpected type, defaulting to 10");
+            }
+        }
 
-    const auto MINHALFBORDER = std::min(borderBox.w, borderBox.h) / 2.0;
+        // Parse rotation (angle in degrees)
+        angle = 0.0;
+        if (props.contains("rotate")) {
+            auto val = props.at("rotate");
+            if (val.type() == typeid(Hyprlang::FLOAT)) {
+                angle = std::any_cast<Hyprlang::FLOAT>(val);
+            } else if (val.type() == typeid(Hyprlang::INT)) {
+                angle = static_cast<float>(std::any_cast<Hyprlang::INT>(val));
+            } else {
+                Debug::log(WARN, "Shape rotate has unexpected type, defaulting to 0");
+            }
+        }
+        angle = angle * M_PI / 180.0; // Convert to radians
+
+        // Parse border (optional)
+        border = 0;
+        if (props.contains("border_size")) {
+            auto val = props.at("border_size");
+            if (val.type() == typeid(Hyprlang::INT)) {
+                border = std::any_cast<Hyprlang::INT>(val);
+            } else {
+                Debug::log(WARN, "Shape border_size has unexpected type, defaulting to 0");
+            }
+        }
 
-    if (xray) {
-        if (border > 0) {
-            const int PIROUND = std::min(MINHALFBORDER, std::round(border * M_PI));
-            g_pRenderer->renderBorder(borderBox, borderGrad, border, rounding == -1 ? PIROUND : std::clamp(rounding, 0, PIROUND), data.opacity);
+        // Parse border gradient (optional)
+        borderGrad = CGradientValueData();
+        if (props.contains("border_color")) {
+            try {
+                borderGrad = *CGradientValueData::fromAnyPv(props.at("border_color"));
+            } catch (const std::exception& e) {
+                Debug::log(WARN, "Failed to parse border_color, defaulting to empty gradient: {}", e.what());
+            }
         }
 
-        glEnable(GL_SCISSOR_TEST);
-        glScissor(shapeBox.x, shapeBox.y, shapeBox.width, shapeBox.height);
-        glClearColor(0.0, 0.0, 0.0, 0.0);
-        glClear(GL_COLOR_BUFFER_BIT);
-        glDisable(GL_SCISSOR_TEST);
+        // Parse halign and valign
+        halign = "left";
+        if (props.contains("halign")) {
+            auto val = props.at("halign");
+            if (val.type() == typeid(Hyprlang::STRING)) {
+                halign = std::any_cast<Hyprlang::STRING>(val);
+            }
+        }
+        valign = "top";
+        if (props.contains("valign")) {
+            auto val = props.at("valign");
+            if (val.type() == typeid(Hyprlang::STRING)) {
+                valign = std::any_cast<Hyprlang::STRING>(val);
+            }
+        }
 
-        return data.opacity < 1.0;
+        // Adjust position based on halign/valign
+        Vector2D realSize = size + Vector2D{border * 2.0, border * 2.0};
+        pos = posFromHVAlign(viewport, realSize, pos, halign, valign, angle);
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "CShape::configure failed: {}", e.what());
+        // Set safe defaults
+        pos = {0, 0};
+        size = {100, 100};
+        color = CHyprColor(1.0, 1.0, 1.0, 0.5);
+        shapeType = "rectangle";
+        zindex = 10;
+        angle = 0.0;
+        border = 0;
+        blurEnabled = false;
     }
+}
 
-    if (!shapeFB.isAllocated()) {
-        const int ROUND       = roundingForBox(shapeBox, rounding);
-        const int BORDERROUND = roundingForBorderBox(borderBox, rounding, border);
-        Debug::log(LOG, "round: {}, borderround: {}", ROUND, BORDERROUND);
-
-        shapeFB.alloc(borderBox.width + (borderBox.x * 2.0), borderBox.height + (borderBox.y * 2.0), true);
-        g_pRenderer->pushFb(shapeFB.m_iFb);
-        glClearColor(0.0, 0.0, 0.0, 0.0);
-        glClear(GL_COLOR_BUFFER_BIT);
-
-        if (border > 0)
-            g_pRenderer->renderBorder(borderBox, borderGrad, border, BORDERROUND, 1.0);
+bool CShape::draw(const SRenderData& data) {
+    try {
+        CBox box = {pos.x, pos.y, size.x, size.y};
+        box.round();
+        box.rot = angle;
+
+        if (blurEnabled) {
+            if (!shapeFB.isAllocated()) {
+                shapeFB.alloc((int)(size.x + border * 2), (int)(size.y + border * 2), true);
+            }
+
+            shapeFB.bind();
+            glClearColor(0.0, 0.0, 0.0, 0.0);
+            glClear(GL_COLOR_BUFFER_BIT);
+
+            // Draw shape (rectangle for now)
+            if (shapeType == "rectangle") {
+                CBox shapeBox = {border, border, size.x, size.y};
+                g_pRenderer->renderRect(shapeBox, color, 0);
+                if (border > 0 && !borderGrad.m_vColorsOkLabA.empty()) {
+                    CBox borderBox = {0, 0, size.x + border * 2, size.y + border * 2};
+                    g_pRenderer->renderBorder(borderBox, borderGrad, border, 0, data.opacity);
+                }
+            } else {
+                Debug::log(WARN, "Shape type {} not implemented, rendering rectangle", shapeType);
+                g_pRenderer->renderRect(box, color, 0);
+            }
+
+            // Apply blur
+            CRenderer::SBlurParams rendererBlurParams = {
+                .size = blurParams.size,
+                .passes = blurParams.passes,
+                // Default values for other fields
+            };
+            g_pRenderer->blurFB(shapeFB, rendererBlurParams);
+            glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
+
+            // Render blurred texture
+            CBox texBox = {pos.x - border, pos.y - border, size.x + border * 2, size.y + border * 2};
+            texBox.round();
+            texBox.rot = angle;
+            g_pRenderer->renderTexture(texBox, shapeFB.m_cTex, data.opacity, 0, HYPRUTILS_TRANSFORM_FLIPPED_180);
+        } else {
+            // Draw without blur
+            if (shapeType == "rectangle") {
+                g_pRenderer->renderRect(box, color, 0);
+                if (border > 0 && !borderGrad.m_vColorsOkLabA.empty()) {
+                    CBox borderBox = {pos.x - border, pos.y - border, size.x + border * 2, size.y + border * 2};
+                    borderBox.round();
+                    borderBox.rot = angle;
+                    g_pRenderer->renderBorder(borderBox, borderGrad, border, 0, data.opacity);
+                }
+            } else {
+                Debug::log(WARN, "Shape type {} not implemented, rendering rectangle", shapeType);
+                g_pRenderer->renderRect(box, color, 0);
+            }
+        }
 
-        g_pRenderer->renderRect(shapeBox, color, ROUND);
-        g_pRenderer->popFb();
+        return data.opacity < 1.0;
+    } catch (const std::exception& e) {
+        Debug::log(ERR, "CShape::draw failed: {}", e.what());
+        return false;
     }
-
-    CTexture* tex    = &shapeFB.m_cTex;
-    CBox      texbox = {pos, tex->m_vSize};
-
-    texbox.round();
-    texbox.rot = angle;
-
-    g_pRenderer->renderTexture(texbox, *tex, data.opacity, 0, HYPRUTILS_TRANSFORM_FLIPPED_180);
-
-    return data.opacity < 1.0;
-}
+}
\ No newline at end of file
diff --git a/src/renderer/widgets/Shape.hpp b/src/renderer/widgets/Shape.hpp
index 25c43a06..5f790245 100644
--- a/src/renderer/widgets/Shape.hpp
+++ b/src/renderer/widgets/Shape.hpp
@@ -11,34 +11,37 @@
 
 class CShape : public IWidget {
   public:
-    CShape()          = default;
+    CShape() = default;
     virtual ~CShape() = default;
 
-    void         registerSelf(const SP<CShape>& self);
+    void registerSelf(const SP<CShape>& self);
 
-    virtual void configure(const std::unordered_map<std::string, std::any>& prop, const SP<COutput>& pOutput);
-    virtual bool draw(const SRenderData& data);
+    virtual void configure(const std::unordered_map<std::string, std::any>& prop, const SP<COutput>& pOutput) override;
+    virtual bool draw(const SRenderData& data) override;
+    virtual std::string type() const override; // Added for layered rendering
 
   private:
-    WP<CShape>         m_self;
-
-    CFramebuffer       shapeFB;
-
-    int                rounding;
-    double             border;
-    double             angle;
-    CHyprColor         color;
+    WP<CShape> m_self;
+
+    CFramebuffer shapeFB;
+
+    std::string shapeType; // e.g., "rectangle"
+    bool blurEnabled = false;
+    struct {
+        int size = 0;
+        int passes = 0;
+    } blurParams;
+    int zindex = 10; // Default: above background, below input-field
+
+    int rounding;
+    double border;
+    double angle;
+    CHyprColor color;
     CGradientValueData borderGrad;
-    Vector2D           size;
-    Vector2D           pos;
-    CBox               shapeBox;
-    CBox               borderBox;
-    bool               xray;
-
-    std::string        halign, valign;
-
-    bool               firstRender = true;
+    Vector2D size;
+    Vector2D pos;
 
-    Vector2D           viewport;
-    CShadowable        shadow;
-};
+    std::string halign, valign;
+    Vector2D viewport;
+    CShadowable shadow;
+};
\ No newline at end of file

From 28440e6dd89a40328ddd0ea649c0d8a95099eb67 Mon Sep 17 00:00:00 2001
From: RAMA <70065309+nomadxxxx@users.noreply.github.com>
Date: Thu, 10 Apr 2025 14:38:24 +1000
Subject: [PATCH 4/4] mpvpaper functionality

---
 src/config/ConfigManager.cpp        | 20 ++++++--
 src/config/ConfigManager.hpp        | 11 +++--
 src/renderer/Renderer.cpp           | 77 +++++++++++++++++++++++++----
 src/renderer/Renderer.hpp           |  8 +--
 src/renderer/widgets/Background.cpp | 23 +++++----
 src/renderer/widgets/Background.hpp |  5 +-
 6 files changed, 113 insertions(+), 31 deletions(-)

diff --git a/src/config/ConfigManager.cpp b/src/config/ConfigManager.cpp
index 12e43927..0f430359 100644
--- a/src/config/ConfigManager.cpp
+++ b/src/config/ConfigManager.cpp
@@ -98,7 +98,6 @@ static void configHandleLayoutOptionDestroy(void** data) {
     if (*data)
         delete reinterpret_cast<CLayoutValueData*>(*data);
 }
-
 static Hyprlang::CParseResult configHandleGradientSet(const char* VALUE, void** data) {
     const std::string V = VALUE;
 
@@ -201,6 +200,7 @@ inline static constexpr auto GRADIENTCONFIG = [](const char* default_value) -> H
 inline static constexpr auto LAYOUTCONFIG = [](const char* default_value) -> Hyprlang::CUSTOMTYPE {
     return Hyprlang::CUSTOMTYPE{&configHandleLayoutOption, configHandleLayoutOptionDestroy, default_value};
 };
+
 void CConfigManager::init() {
     #define SHADOWABLE(name)                                                                                                                                                           \
         m_config.addSpecialConfigValue(name, "shadow_size", Hyprlang::INT{3});                                                                                                         \
@@ -227,7 +227,7 @@ void CConfigManager::init() {
     
         m_config.addSpecialCategory("background", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
         m_config.addSpecialConfigValue("background", "monitor", Hyprlang::STRING{""});
-        m_config.addSpecialConfigValue("background", "type", Hyprlang::STRING{"image"});  // New type field
+        m_config.addSpecialConfigValue("background", "type", Hyprlang::STRING{"image"});
         m_config.addSpecialConfigValue("background", "path", Hyprlang::STRING{""});
         m_config.addSpecialConfigValue("background", "color", Hyprlang::INT{0xFF111111});
         m_config.addSpecialConfigValue("background", "blur_size", Hyprlang::INT{8});
@@ -242,6 +242,11 @@ void CConfigManager::init() {
         m_config.addSpecialConfigValue("background", "reload_cmd", Hyprlang::STRING{""});
         m_config.addSpecialConfigValue("background", "crossfade_time", Hyprlang::FLOAT{-1.0});
         m_config.addSpecialConfigValue("background", "fallback_path", Hyprlang::STRING{""});
+        m_config.addSpecialConfigValue("background", "mpvpaper_mute", Hyprlang::INT{1});
+        m_config.addSpecialConfigValue("background", "mpvpaper_fps", Hyprlang::INT{30});
+        m_config.addSpecialConfigValue("background", "mpvpaper_panscan", Hyprlang::FLOAT{1.0});
+        m_config.addSpecialConfigValue("background", "mpvpaper_hwdec", Hyprlang::STRING{"vaapi"});
+        m_config.addSpecialConfigValue("background", "mpvpaper_layer", Hyprlang::STRING{"bottom"});
     
         m_config.addSpecialCategory("shape", Hyprlang::SSpecialCategoryOptions{.key = nullptr, .anonymousKeyBased = true});
         m_config.addSpecialConfigValue("shape", "monitor", Hyprlang::STRING{""});
@@ -360,6 +365,7 @@ void CConfigManager::init() {
 
 std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
     std::vector<CConfigManager::SWidgetConfig> result;
+    std::vector<std::string> keys;
 
     #define SHADOWABLE(name)                                                                                                                                                           \
         {"shadow_size", m_config.getSpecialConfigValue(name, "shadow_size", k.c_str())}, {"shadow_passes", m_config.getSpecialConfigValue(name, "shadow_passes", k.c_str())},          \
@@ -368,7 +374,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
         }
 
     //
-    auto keys = m_config.listKeysForSpecialCategory("background");
+    keys = m_config.listKeysForSpecialCategory("background");
     result.reserve(keys.size());
     for (auto& k : keys) {
         // clang-format off
@@ -391,6 +397,11 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
                 {"reload_cmd", m_config.getSpecialConfigValue("background", "reload_cmd", k.c_str())},
                 {"crossfade_time", m_config.getSpecialConfigValue("background", "crossfade_time", k.c_str())},
                 {"fallback_path", m_config.getSpecialConfigValue("background", "fallback_path", k.c_str())},
+                {"mpvpaper_mute", m_config.getSpecialConfigValue("background", "mpvpaper_mute", k.c_str())},
+                {"mpvpaper_fps", m_config.getSpecialConfigValue("background", "mpvpaper_fps", k.c_str())},
+                {"mpvpaper_panscan", m_config.getSpecialConfigValue("background", "mpvpaper_panscan", k.c_str())},
+                {"mpvpaper_hwdec", m_config.getSpecialConfigValue("background", "mpvpaper_hwdec", k.c_str())},
+                {"mpvpaper_layer", m_config.getSpecialConfigValue("background", "mpvpaper_layer", k.c_str())},
             }
         });
         // clang-format on
@@ -447,6 +458,7 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
         // clang-format on
     }
 
+    //
     keys = m_config.listKeysForSpecialCategory("input-field");
     for (auto& k : keys) {
         // clang-format off
@@ -488,6 +500,8 @@ std::vector<CConfigManager::SWidgetConfig> CConfigManager::getWidgetConfigs() {
         });
         // clang-format on
     }
+
+    //
     keys = m_config.listKeysForSpecialCategory("label");
     for (auto& k : keys) {
         // clang-format off
diff --git a/src/config/ConfigManager.hpp b/src/config/ConfigManager.hpp
index 9183f2bf..0bd434c2 100644
--- a/src/config/ConfigManager.hpp
+++ b/src/config/ConfigManager.hpp
@@ -19,10 +19,13 @@ class CConfigManager {
         return Hyprlang::CSimpleConfigValue<T>(&m_config, name.c_str());
     }
 
+    // Structure for widget configurations (background, shape, image, input-field, label)
     struct SWidgetConfig {
-        std::string                               type;
-        std::string                               monitor;
-
+        std::string                               type;    // Widget type (e.g., "background")
+        std::string                               monitor; // Monitor name (e.g., "DP-3")
+        // Map of configuration values, e.g.:
+        // For background: "path", "type", "color", "mpvpaper_mute", "mpvpaper_fps", etc.
+        // For input-field: "size", "inner_color", etc.
         std::unordered_map<std::string, std::any> values;
     };
 
@@ -40,4 +43,4 @@ class CConfigManager {
     Hyprlang::CConfig m_config;
 };
 
-inline UP<CConfigManager> g_pConfigManager;
+inline UP<CConfigManager> g_pConfigManager;
\ No newline at end of file
diff --git a/src/renderer/Renderer.cpp b/src/renderer/Renderer.cpp
index 98b69edd..5f725526 100644
--- a/src/renderer/Renderer.cpp
+++ b/src/renderer/Renderer.cpp
@@ -22,7 +22,9 @@
 #include <unistd.h>
 #include <signal.h>
 #include <stdexcept>
-#include <mutex> // Added for mpvpaper safeguards
+#include <mutex>
+#include <vector>
+#include <sstream>
 
 inline const float fullVerts[] = {
     1, 0, // top right
@@ -223,15 +225,27 @@ CRenderer::CRenderer() {
         throw;
     }
 }
-
 void CRenderer::renderBackground(const CSessionLockSurface& surf, float opacity) {
     try {
         auto widgets = getOrCreateWidgetsFor(surf);
+        bool hasVideoBackground = false;
         for (auto& w : widgets) {
             if (w->type() == "background") {
+                auto* bgWidget = dynamic_cast<CBackground*>(w.get());
+                if (bgWidget && bgWidget->isVideoBackground()) {
+                    hasVideoBackground = true;
+                    continue; // Skip rendering static background for video
+                }
                 w->draw({opacity});
             }
         }
+        if (hasVideoBackground) {
+            static bool logged = false; // Log only once to avoid spam
+            if (!logged) {
+                Debug::log(LOG, "Skipping static background rendering; using video background via mpvpaper");
+                logged = true;
+            }
+        }
     } catch (const std::exception& e) {
         Debug::log(ERR, "renderBackground failed for output {}: {}", surf.m_outputRef.lock()->stringPort, e.what());
     }
@@ -307,6 +321,7 @@ CRenderer::SRenderFeedback CRenderer::renderLock(const CSessionLockSurface& surf
         return {};
     }
 }
+
 void CRenderer::renderRect(const CBox& box, const CHyprColor& col, int rounding) {
     try {
         const auto ROUNDEDBOX = box.copy().round();
@@ -374,7 +389,6 @@ void CRenderer::renderBorder(const CBox& box, const CGradientValueData& gradient
         Debug::log(ERR, "renderBorder failed: {}", e.what());
     }
 }
-
 void CRenderer::renderTexture(const CBox& box, const CTexture& tex, float a, int rounding, std::optional<eTransform> tr) {
     try {
         const auto ROUNDEDBOX = box.copy().round();
@@ -518,6 +532,7 @@ std::vector<SP<IWidget>>& CRenderer::getOrCreateWidgetsFor(const CSessionLockSur
         return empty;
     }
 }
+
 void CRenderer::blurFB(const CFramebuffer& outfb, SBlurParams params) {
     try {
         glDisable(GL_BLEND);
@@ -629,7 +644,6 @@ void CRenderer::blurFB(const CFramebuffer& outfb, SBlurParams params) {
         glEnable(GL_BLEND);
     }
 }
-
 void CRenderer::pushFb(GLint fb) {
     try {
         boundFBs.push_back(fb);
@@ -699,18 +713,61 @@ bool CRenderer::startMpvpaper(const std::string& monitor, const std::string& vid
             return true;
         }
         Debug::log(LOG, "Starting mpvpaper for monitor {} with video {}", monitor, videoPath);
+
+        // Get background widget config to read mpvpaper options
+        std::string mpvOptions = "loop";
+        std::string layer = "overlay"; // Default to overlay for lock screen
+        auto configs = g_pConfigManager->getWidgetConfigs();
+        for (const auto& config : configs) {
+            if (config.type == "background" && config.monitor == monitor) {
+                try {
+                    if (config.values.contains("mpvpaper_mute")) {
+                        int mute = std::any_cast<Hyprlang::INT>(config.values.at("mpvpaper_mute"));
+                        if (mute) mpvOptions += " mute=yes";
+                    }
+                    if (config.values.contains("mpvpaper_fps")) {
+                        int fps = std::any_cast<Hyprlang::INT>(config.values.at("mpvpaper_fps"));
+                        if (fps > 0) mpvOptions += " --vf=fps=" + std::to_string(fps); // Use --vf=fps instead of --fps
+                    }
+                    if (config.values.contains("mpvpaper_panscan")) {
+                        float panscan = std::any_cast<Hyprlang::FLOAT>(config.values.at("mpvpaper_panscan"));
+                        if (panscan >= 0) mpvOptions += " panscan=" + std::to_string(panscan);
+                    }
+                    if (config.values.contains("mpvpaper_hwdec")) {
+                        std::string hwdec = std::any_cast<Hyprlang::STRING>(config.values.at("mpvpaper_hwdec"));
+                        if (!hwdec.empty()) mpvOptions += " --hwdec=" + hwdec;
+                    }
+                    if (config.values.contains("mpvpaper_layer")) {
+                        std::string configLayer = std::any_cast<Hyprlang::STRING>(config.values.at("mpvpaper_layer"));
+                        if (!configLayer.empty()) layer = configLayer;
+                    }
+                } catch (const std::exception& e) {
+                    Debug::log(WARN, "Failed to parse mpvpaper options for monitor {}: {}", monitor, e.what());
+                }
+                break;
+            }
+        }
+
+        // Split options into arguments
+        std::vector<std::string> args = {"mpvpaper", "-l", layer, "-o", mpvOptions, monitor, videoPath};
+        std::vector<char*> argv;
+        for (auto& arg : args) {
+            argv.push_back(const_cast<char*>(arg.c_str()));
+        }
+        argv.push_back(nullptr);
+
         pid_t pid = fork();
         if (pid == 0) {
-            // Redirect stderr to log file for debugging
-            freopen("/tmp/mpvpaper.log", "w", stderr);
-            // Use minimal mpvpaper options, relying on default Wayland surface layering
-            execlp("mpvpaper", "mpvpaper", "-o", "loop panscan=1.0 mute=yes", monitor.c_str(), videoPath.c_str(), (char*)nullptr);
-            Debug::log(ERR, "execlp failed for mpvpaper on monitor {} with video {}: errno {}", monitor, videoPath, errno);
+            // Redirect stderr to unique log file
+            std::string logFile = "/tmp/mpvpaper_hyprlock_" + std::to_string(getpid()) + ".log";
+            freopen(logFile.c_str(), "w", stderr);
+            execvp("mpvpaper", argv.data());
+            Debug::log(ERR, "execvp failed for mpvpaper on monitor {} with video {}: errno {}", monitor, videoPath, errno);
             _exit(1);
         } else if (pid > 0) {
             mpvpaperPids[monitor] = pid;
             mpvpaperVideoPaths[monitor] = videoPath;
-            Debug::log(LOG, "Started mpvpaper for monitor {} with PID {}", monitor, pid);
+            Debug::log(LOG, "Started mpvpaper for monitor {} with PID {} and options '{}'", monitor, pid, mpvOptions);
             return true;
         } else {
             Debug::log(ERR, "Fork failed for mpvpaper on monitor {}: errno {}", monitor, errno);
diff --git a/src/renderer/Renderer.hpp b/src/renderer/Renderer.hpp
index 78cc6225..d4cd0349 100644
--- a/src/renderer/Renderer.hpp
+++ b/src/renderer/Renderer.hpp
@@ -2,7 +2,7 @@
 
 #include <chrono>
 #include <optional>
-#include <mutex> // Added for mpvpaperMutex
+#include <mutex>
 #include "Shader.hpp"
 #include "../defines.hpp"
 #include "../core/LockSurface.hpp"
@@ -14,6 +14,8 @@
 #include "Framebuffer.hpp"
 #include <map>
 #include <string>
+#include <unordered_map>
+#include <vector>
 
 typedef std::unordered_map<OUTPUTID, std::vector<SP<IWidget>>> widgetMap_t;
 
@@ -40,7 +42,7 @@ class CRenderer {
     void            renderTextureMix(const CBox& box, const CTexture& tex, const CTexture& tex2, float a = 1.0, float mixFactor = 0.0, int rounding = 0, std::optional<eTransform> tr = {});
     void            blurFB(const CFramebuffer& outfb, SBlurParams params);
 
-    // Added methods for layered rendering
+    // Layered rendering methods
     void            renderBackground(const CSessionLockSurface& surf, float opacity);
     void            renderShapes(const CSessionLockSurface& surf, float opacity);
     void            renderInputFields(const CSessionLockSurface& surf, float opacity);
@@ -82,7 +84,7 @@ class CRenderer {
 
     std::map<std::string, pid_t> mpvpaperPids;
     std::map<std::string, std::string> mpvpaperVideoPaths;
-    std::mutex                mpvpaperMutex; // Added for safe PID management
+    std::mutex                mpvpaperMutex; // For safe PID management
 
     std::vector<GLint>        boundFBs;
 };
diff --git a/src/renderer/widgets/Background.cpp b/src/renderer/widgets/Background.cpp
index e0f659c9..d211bd7b 100644
--- a/src/renderer/widgets/Background.cpp
+++ b/src/renderer/widgets/Background.cpp
@@ -13,9 +13,9 @@ extern UP<CRenderer> g_pRenderer;
 
 CBackground::~CBackground() {
     reset();
-    if (isVideoBackground && !monitor.empty()) {
+    if (m_bIsVideoBackground && !monitor.empty()) {
         g_pRenderer->stopMpvpaper(monitor);
-        isVideoBackground = false;
+        m_bIsVideoBackground = false;
     }
 }
 
@@ -27,6 +27,10 @@ std::string CBackground::type() const {
     return "background";
 }
 
+bool CBackground::isVideoBackground() const {
+    return m_bIsVideoBackground;
+}
+
 void CBackground::configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput) {
     try {
         reset();
@@ -251,7 +255,7 @@ void CBackground::configure(const std::unordered_map<std::string, std::any>& pro
             }
         }
 
-        isVideoBackground = false;
+        m_bIsVideoBackground = false;
         videoPath = "";
         resourceID = "";
         if (type == "video" || path.ends_with(".mp4")) {
@@ -260,11 +264,12 @@ void CBackground::configure(const std::unordered_map<std::string, std::any>& pro
             if (!path.empty()) {
                 Debug::log(LOG, "Attempting to start mpvpaper for monitor {} with video {}", monitor, path);
                 bool mpvSuccess = g_pRenderer->startMpvpaper(monitor, path);
-                isVideoBackground = mpvSuccess;
+                m_bIsVideoBackground = mpvSuccess;
                 if (!mpvSuccess) {
                     if (!fallbackPath.empty() && !fallbackPath.ends_with(".mp4")) {
                         Debug::log(LOG, "Video background failed, using fallback: {}", fallbackPath);
                         resourceID = "background:" + fallbackPath;
+                        m_bIsVideoBackground = false; // Ensure fallback image renders
                     } else {
                         Debug::log(ERR, "Video background failed and no valid fallback path provided, using transparent.");
                         resourceID = "";
@@ -279,7 +284,7 @@ void CBackground::configure(const std::unordered_map<std::string, std::any>& pro
         outputPort = pOutput->stringPort;
         transform = isScreenshot ? wlTransformToHyprutils(invertTransform(pOutput->transform)) : HYPRUTILS_TRANSFORM_NORMAL;
 
-        if (isScreenshot && !isVideoBackground) {
+        if (isScreenshot && !m_bIsVideoBackground) {
             if (g_pRenderer->asyncResourceGatherer->gathered) {
                 if (!g_pRenderer->asyncResourceGatherer->getAssetByID(resourceID))
                     resourceID = "";
@@ -290,7 +295,7 @@ void CBackground::configure(const std::unordered_map<std::string, std::any>& pro
             }
         }
 
-        if (!isScreenshot && !isVideoBackground && reloadTime > -1) {
+        if (!isScreenshot && !m_bIsVideoBackground && reloadTime > -1) {
             try {
                 modificationTime = std::filesystem::last_write_time(absolutePath(path, ""));
             } catch (std::exception& e) { Debug::log(ERR, "{}", e.what()); }
@@ -298,7 +303,7 @@ void CBackground::configure(const std::unordered_map<std::string, std::any>& pro
         }
     } catch (const std::exception& e) {
         Debug::log(ERR, "Exception in CBackground::configure: {}", e.what());
-        isVideoBackground = false;
+        m_bIsVideoBackground = false;
         resourceID = "";
     }
 }
@@ -323,7 +328,7 @@ void CBackground::renderRect(CHyprColor color) {
 }
 
 bool CBackground::draw(const SRenderData& data) {
-    if (isVideoBackground) {
+    if (m_bIsVideoBackground) {
         Debug::log(LOG, "Skipping static background rendering; using video background via mpvpaper");
         return false; // mpvpaper handles rendering
     }
@@ -440,7 +445,7 @@ void CBackground::onReloadTimerUpdate() {
             return;
     }
 
-    if (isVideoBackground)
+    if (m_bIsVideoBackground)
         return;
 
     try {
diff --git a/src/renderer/widgets/Background.hpp b/src/renderer/widgets/Background.hpp
index 015b8ae8..72cb6281 100644
--- a/src/renderer/widgets/Background.hpp
+++ b/src/renderer/widgets/Background.hpp
@@ -31,7 +31,8 @@ class CBackground : public IWidget {
 
     virtual void configure(const std::unordered_map<std::string, std::any>& props, const SP<COutput>& pOutput) override;
     virtual bool draw(const SRenderData& data) override;
-    virtual std::string type() const override; // Added for layered rendering
+    virtual std::string type() const override;
+    virtual bool isVideoBackground() const; // Method for video background check
 
     void         reset(); // Unload assets, remove timers, etc.
 
@@ -43,7 +44,7 @@ class CBackground : public IWidget {
     void         startCrossFadeOrUpdateRender();
 
     // Members for video background support
-    bool         isVideoBackground = false;
+    bool         m_bIsVideoBackground = false; // Renamed to avoid conflict
     std::string  videoPath;
     std::string  monitor; // Store monitor name for mpvpaper
     std::string  fallbackPath; // Added for fallback image if video fails
